{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///infernal-engine.min.js","webpack:///webpack/bootstrap b4012e7b42b1be86f0d1?0431","webpack:///./lib/index.js?bdd8","webpack:///./~/process/browser.js?82e4","webpack:///./lib/agenda.js?7b45","webpack:///./lib/utils.js?cd26","webpack:///./lib/engine-proxy.js?257d"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","process","InfernalEngine","timeout","_facts","_rules","_relations","_diffFacts","_trace","_agenda","Agenda","_infering","applyFacts","context","source","loading","sourceType","Date","Array","addRule","property","set","updateAgenda","factName","undefined","rules","ruleName","hasOwnProperty","EngineProxy","utils","prototype","reset","nextTick","action","bind","get","charAt","fact","digPath","data","name","value","oldValue","equals","fullName","newValue","notify","rule","indexOf","ruleContent","toString","regex","match","exec","getContext","getFullName","getDiff","diff","getFacts","deepCopy","setFacts","facts","load","model","infer","callback","actualCallback","isEmpty","clearTimeout","timeoutId","setTimeout","Error","proxy","shift","_executeRule","err","startTracing","traceFunction","stopTracing","cleanUpNextTick","draining","currentQueue","length","queue","concat","queueIndex","drainQueue","len","run","Item","fun","array","noop","args","arguments","i","push","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","umask","key","path","create","hierarchy","split","heap","factFullName","pop","currentContext","lastSlash","lastIndexOf","substring","contextArray","pathArray","contextStack","stack","contextPart","target","propertyType","a","b","aValue","getTime","bValue","engine","fullFactName","self","trace","message"],"mappings":"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","file":"infernal-engine.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"InfernalEngine\"] = factory();\n\telse\n\t\troot[\"InfernalEngine\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"InfernalEngine\"] = factory();\n\telse\n\t\troot[\"InfernalEngine\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {/**\n\t * Main module of the library, defines the class InfernalEngine and its\n\t * private methods.\n\t * Module infernal-engine\n\t */\n\t\n\t\"use strict\";\n\t\n\tvar Agenda      = __webpack_require__(2);\n\tvar utils       = __webpack_require__(3);\n\tvar EngineProxy = __webpack_require__(4);\n\t\n\tmodule.exports = InfernalEngine;\n\t\n\t\n\t/**\n\t * InfernalEngine class constructor.\n\t * @class\n\t *\n\t * @param {number} [timeout=5000] - How long the inference can take before\n\t *        the inference callback is called with a timeout error.\n\t *\n\t * @property {number} timeout - The timeout value in milliseconds set by the \n\t *                              constructor.\n\t */\n\tfunction InfernalEngine(timeout) {\n\t    this._facts     = {}; // Graph of facts\n\t    this._rules     = {}; // Map between rule names and rules (function)\n\t    this._relations = {}; // Map between fact names and all related rules\n\t    this._diffFacts = null; // A map of fact names that changed\n\t    this._trace     = null; // the tracing function\n\t    this._agenda    = new Agenda();\n\t    this._infering  = false;\n\t\n\t    this.timeout    = 5000;\n\t\n\t    if (timeout) {\n\t        this.timeout = timeout;\n\t    }\n\t}\n\t\n\t/**\n\t * Resets the engine to its inintial state. Do not change timeout value \n\t * nor the tracer function.\n\t */\n\tInfernalEngine.prototype.reset = function() {\n\t    this._facts     = {};\n\t    this._rules     = {};\n\t    this._relations = {};\n\t    this._diffFacts = null;\n\t    this._agenda    = new Agenda();\n\t    this._infering  = false;\n\t    if (typeof this._trace === \"function\") {\n\t        process.nextTick((function() {\n\t            this._trace({action: \"reset\"});\n\t        }).bind(this));\n\t    }\n\t};\n\t\n\t/**\n\t * Gets a value of the given factName. A factName is made of a context and \n\t * the fact simple name separated by '/'. Accessing a fact from the engine\n\t * assumes the context to be \"/\". Within a rule, the context\n\t * would be the same as the rule context.\n\t * \n\t * @param {string} factName - The fact name.\n\t * @returns {*} the fact value.\n\t */\n\tInfernalEngine.prototype.get = function(factName) {\n\t    if (factName.charAt(0) !== \"/\") {\n\t        return this.get(\"/\" + factName);\n\t    }\n\t\n\t    var fact = utils.digPath.call(this, this._facts, factName);\n\t    if (fact === undefined) {\n\t        return undefined;\n\t    }\n\t\n\t    return fact.data[fact.name];\n\t};\n\t\n\t\n\t/**\n\t * Sets a fact value for the given factName.\n\t *\n\t * @param {string} factName - The fact name.\n\t * @param {*} value - The fact value to be set.\n\t */\n\tInfernalEngine.prototype.set = function(factName, value) {\n\t   \n\t    if (factName.charAt(0) !== \"/\") {\n\t        return this.set(\"/\" + factName, value);\n\t    }\n\t\n\t    var oldValue = this.get(factName);\n\t    if (!utils.equals(oldValue, value)) {\n\t        var fact = utils.digPath.call(this, this._facts, factName, true);\n\t        \n\t        if (this._diffFacts) {\n\t            this._diffFacts[fact.fullName] = true;\n\t        }\n\t        \n\t        var oldValue = fact.data[fact.name];\n\t        fact.data[fact.name] = value;\n\t        \n\t        updateAgenda.call(this, factName);\n\t\n\t        if ((typeof this._trace === \"function\") && !this._infering) {\n\t            process.nextTick((function() {\n\t                this._trace({\n\t                    action: \"set\",\n\t                    fact: factName,\n\t                    oldValue: oldValue,\n\t                    newValue: value\n\t                });\n\t            }).bind(this));\n\t        }\n\t    }\n\t\n\t    return this;\n\t};\n\t\n\t\n\t/**\n\t * Notifies the engine to consider the given factName was updated. This method\n\t * is usefull when changing the content of an array without changing the array\n\t * reference.\n\t *\n\t * @param {string} factName - The fact name that have to be considered \n\t *                            changed by the engine.\n\t * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\n\t */\n\tInfernalEngine.prototype.notify = function(factName) {\n\t    if (factName.charAt(0) !== \"/\") {\n\t        return this.notify(\"/\" + factName, value);\n\t    }\n\t    updateAgenda.call(this, factName);\n\t    if ((typeof this._trace === \"function\") && !this._infering) {\n\t        process.nextTick((function() {\n\t            this._trace({\n\t                action: \"notify\",\n\t                fact: factName,\n\t                newValue: value\n\t            });\n\t        }).bind(this));\n\t    }\n\t    return this;\n\t};\n\t\n\t\n\t/**\n\t * Adds a rule to the engine.\n\t * \n\t * @param {string} ruleName\n\t *        The rule name, each segment separated by a '/'. A rule name cannot\n\t *        ends with '/'.\n\t *\n\t * @param {rule} rule \n\t *        The rule function has only one paramter: the 'done' function. When\n\t *        the rule evaluation is terminated, the done function must be called\n\t *        to tell the engine to execute the next rule in the agenda.\n\t *\n\t * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\n\t */\n\tInfernalEngine.prototype.addRule = function(ruleName, rule) {\n\t    if (typeof ruleName === \"function\") {\n\t        rule = ruleName;\n\t        ruleName = \"/\" + rule.name;\n\t    }\n\t    \n\t    if (ruleName.indexOf(\"/\") !== 0) {\n\t        ruleName = \"/\" + ruleName;\n\t    }\n\t    \n\t    var ruleContent = rule.toString();\n\t    var regex = /this\\.get\\([\"']?(.*?)[\"']?\\)/gm;\n\t    var match = regex.exec(ruleContent);\n\t    var factName;\n\t    this._rules[ruleName] = rule;\n\t\n\t    while (match) {\n\t        var context = utils.getContext(\"/\", ruleName);\n\t        factName = utils.getFullName(context, match[1]);\n\t        if (this._relations[factName] === undefined) {\n\t            this._relations[factName] = {};\n\t        }\n\t        this._relations[factName][ruleName] = true;\n\t        match = regex.exec(ruleContent);\n\t    }\n\t\n\t    if (typeof this._trace === \"function\") {\n\t        this._trace({action: \"addRule\", rule: ruleName});\n\t    }\n\t\n\t    return this;\n\t};\n\t\n\t\n\t/**\n\t * Gets the subset of facts that changed during the last call to infer().\n\t *\n\t * @returns {object} an object containing all facts that changed during the \n\t *                   last inference.\n\t */\n\tInfernalEngine.prototype.getDiff = function() {\n\t    var diff = {};\n\t    for (var factName in this._diffFacts) {\n\t        var fact = utils.digPath(diff, factName, true);\n\t        fact.data[fact.name] = this.get(factName);\n\t    }\n\t    return diff;\n\t};\n\t\n\t\n\t/**\n\t * Gets a deep copy of the internal facts object. When a fact contains an \n\t * array, that array reference is kept in the returned object. Modifying \n\t * that array would result in modifying the original array from the internal\n\t * facts.\n\t * \n\t * @returns {object} a deep copy of the internal facts.\n\t */\n\tInfernalEngine.prototype.getFacts = function() {\n\t    return utils.deepCopy(this._facts);\n\t};\n\t\n\t/**\n\t * Sets the internal facts to the values received in the facts parameter. The \n\t * internal facts reference is not changed to the object received. Instead,\n\t * the object tree is is read and each fact it contains are \"set\" so that any\n\t * changes to the actual internal fact values will trigger rules as required. \n\t * Functions are ingnored by that operation.\n\t *\n\t * @param {object} An object tree used to update internal facts.\n\t *\n\t * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\n\t */\n\tInfernalEngine.prototype.setFacts = function(facts) {\n\t    applyFacts.call(this, \"\", facts)\n\t    return this;\n\t};\n\t\n\t/**\n\t * Loads a model into the engine. This operation resets the engine and loads\n\t * that model's properties as facts and methods as rules.\n\t *\n\t * @param {object} model - A model object containing facts and rules.\n\t *\n\t * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\n\t */\n\tInfernalEngine.prototype.load = function(model) {\n\t    this.reset();\n\t    applyFacts.call(this, \"\", model, true);\n\t    return this;\n\t};\n\t\n\t\n\t/**\n\t * Starts the inference. The inference executes all rules in the agenda. Once\n\t * the inference is done, either because the agenda is empty or becaus the \n\t * inference timeout is reached, the callback method is called.\n\t *\n\t * @param {number} [timeout=InfernalEngine#timeout] The timeout period in \n\t *        milliseconds given to the infer call.\n\t *\n\t * @param {inferenceCallback} callback - The function to be executed when done.\n\t *\n\t * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\n\t */\n\tInfernalEngine.prototype.infer = function(timeout, callback) {\n\t    if (typeof timeout === \"function\") {\n\t        var actualCallback = timeout;\n\t        this.infer(this.timeout, actualCallback);\n\t        return;\n\t    }\n\t\n\t    if (this._agenda.isEmpty()) {\n\t        this._infering = false;\n\t        clearTimeout(this.timeoutId);\n\t        callback();\n\t        return;\n\t    }\n\t\n\t    if (timeout > 0 ) {\n\t        this._infering = true;\n\t        this._diffFacts = {};\n\t        this.timeoutId = setTimeout((function() {\n\t            this._infering = false;\n\t            callback(new Error( \n\t                \"Inference timed out after \" + timeout + \" ms\"));\n\t            return;\n\t        }).bind(this), timeout);\n\t        if (typeof this._trace === \"function\") {\n\t            process.nextTick((function() {\n\t                this._trace({action: \"infer\"});\n\t            }).bind(this));\n\t        }\n\t    }\n\t\n\t    if (this._infering === false) {\n\t        callback(new Error(\"The timeout parameter must be grater than zero \" +\n\t            \"to start infering.\"));\n\t        return;\n\t    }\n\t\n\t    var proxy = this._agenda.shift();\n\t    \n\t    process.nextTick((function() {\n\t        proxy._executeRule((function(err) {\n\t            if(err) {\n\t                this._infering = false;\n\t                clearTimeout(this.timeoutId);\n\t                callback(err);\n\t                return;\n\t            }\n\t            if (this._infering) {\n\t                this.infer(0, callback);\n\t            }\n\t        }).bind(this));\n\t    }).bind(this));\n\t\n\t    return this;\n\t};\n\t\n\t\n\t/**\n\t * Starts tracing the engine's operations.\n\t * @param {traceCallback} traceFunction The function called when an event\n\t *        is taking place. Events that generate a traceFunction call are:\n\t *        {@link InferenceEngine#reset}, \n\t *        {@link InferenceEngine#set},\n\t *        {@link InferenceEngine#notify},\n\t *        {@link InferenceEngine#addRule},\n\t *        {@link InferenceEngine#infer} and\n\t *        {@link EngineProxy#trace}.\n\t *\n\t * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\n\t */\n\tInfernalEngine.prototype.startTracing = function(traceFunction) {\n\t    if (!traceFunction) {\n\t        throw new Error(\"The parameter 'traceFunction' is mandatory.\");\n\t    }\n\t    this._trace = traceFunction;\n\t    return this;\n\t};\n\t\n\t/**\n\t * Stops calling any trace callback that could have been defined. Has no \n\t * effect if startStracing wasn't called before.\n\t *\n\t * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\n\t */\n\tInfernalEngine.prototype.stopTracing = function() {\n\t    this._trace = null;\n\t    return this;\n\t};\n\t\n\t\n\t\n\t// Private\n\t\n\tfunction applyFacts(context, source, loading) {\n\t    var sourceType = typeof source;\n\t    if ((sourceType === \"object\") && (source instanceof Date)) {\n\t        sourceType = \"date\";\n\t    }\n\t    \n\t    if ((sourceType === \"object\") && (source instanceof Array)) {\n\t        sourceType = \"array\";\n\t    }\n\t    \n\t    if (sourceType === \"function\") {\n\t        if (!loading) {\n\t            return;\n\t        } else {\n\t            this.addRule(context, source);\n\t        }\n\t\n\t    } else if (sourceType === \"object\") {\n\t        for (var property in source) {\n\t            applyFacts.call(this, context + \"/\" + property, source[property], loading);\n\t        }\n\t\n\t    } else {\n\t        this.set(context, source);\n\t    }\n\t}\n\t\n\t\n\tfunction updateAgenda(factName) {\n\t    if (this._relations[factName] !== undefined) {\n\t        var rules = this._relations[factName];\n\t        for (var ruleName in rules) {\n\t            if (rules.hasOwnProperty(ruleName) && \n\t                    (typeof this._agenda[ruleName] === \"undefined\")) {\n\t                this._agenda[ruleName] = new EngineProxy(this, ruleName);\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\t\n\t/**\n\t * The inference callback function.\n\t * @callback inferenceCallback\n\t * @param {Error|*} [err] - The error information if something wrong happened.\n\t */\n\t\n\t\n\t/**\n\t * The done function tells the inference engine that the current rule is \n\t * terminated and that the next rule shall be executed. If no more rule are in\n\t * the agenda, the {@link inferenceCallback} function is called without any \n\t * parameter. If the done function is called with a parameter, the inference \n\t * immediately stops (no more rules are executed from the agenda) and the \n\t * {@link inferenceCallback} is called with the same parameter (the error).\n\t *\n\t * @callback done\n\t * @param {Error|*} [err] - The error information to send to the \n\t *        {@link inferenceCallback}\n\t */\n\t\n\t\n\t/**\n\t * The rule callback is a function that takes a single {@link done} callback \n\t * method. This method is executed in the context of an {@link EngineProxy} \n\t * instance. It is important to note that before exiting a rule function, the\n\t * done callback function has to be called to inform the engine that the next\n\t * rule in the agenda has to be executed. Usually after calling the done \n\t * function the method should exits by explicitely calling 'return' or by \n\t * letting the execution exit the scope of the function.\n\t *\n\t * @callback rule\n\t * @this EngineProxy\n\t * @param {done} done - The done callback to call when the rule terminate\n\t *                      execution.\n\t */\n\t\n\t /**\n\t  * The trace callback is called when an event changing the engine state is \n\t  * hapenning. See {@link InfernalEngine#startTracing} for details.\n\t  *\n\t  * @callback traceCallback\n\t  * @param {object} trace - The trace data.\n\t  * @param {string} trace#action - Can be either 'reset', 'set', 'notify', \n\t  *                                'addRule', 'infer' or 'trace'.\n\t  * @param {string} [trace#rule] - The rule name that generated the trace. This\n\t  *                                property is undefined if the trace was not\n\t  *                                generated during inference.\n\t  * @param {string} [trace#fact] - The fact name if the trace action is 'set' \n\t  *                                or 'notify'.\n\t  * @param {*} [trace#oldValue]  - The previous value of the fact if the trace\n\t  *                                action is 'set'.\n\t  * @param {*} [trace#newValue]  - The new value of the fact if trace action \n\t  *                                is 'set' or 'notify'.\n\t  * @param {string} [trace#message] - The message sent by the \n\t  *                                {@ling EngineProxy#trace} method if trace\n\t  *                                action is 'trace'.\n\t  */\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Module agenda\n\t */\n\t\n\t\"use strict\";\n\t\n\tmodule.exports = Agenda;\n\t\n\t/**\n\t * Create an empty Agenda.\n\t * @class\n\t */\n\tfunction Agenda() {\n\t}\n\t\n\t\n\t/**\n\t * Removes the first element from the agenda and returns it.\n\t * \n\t * @returns {EngineProxy} - The next EngineProxy to be executed.\n\t */\n\tAgenda.prototype.shift = function() {\n\t    for (var key in this) {\n\t        if (key !== \"shift\" && key !== \"isEmpty\") {\n\t            var exec = this[key];\n\t            delete this[key];\n\t            return exec;\n\t        }\n\t    }\n\t}\n\t\n\t/**\n\t * Tells if the agenda is empty.\n\t *\n\t * @returns {boolean} True if the agenda is empty, false otherwise.\n\t */\n\tAgenda.prototype.isEmpty = function() {\n\t    for (var key in this) {\n\t        if (key !== \"shift\" && key !== \"isEmpty\") {\n\t            return false;\n\t        }\n\t    }\n\t    return true;\n\t}\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports.digPath     = digPath;\n\texports.getContext  = getContext;\n\texports.getFullName = getFullName;\n\texports.deepCopy    = deepCopy;\n\texports.equals      = equals;\n\t\n\t\n\t/*\n\t * Dig a path in a root object until it finds the property that contains the \n\t * leaf element of the path.\n\t *\n\t * @param root   The root object to dig into\n\t * @param path   The path formatted with forward slashes. Supports \"..\" to move \n\t *               up one object in the hierarchy.\n\t * @param create If set to true, create the object tree while digging instead \n\t *               of returning undefined when encountering an undefined path \n\t *               element.\n\t * \n\t * @return The last object in the path along with the target leaf name in an \n\t *         object having these two properties: 'target', 'name'. If create is\n\t *         falsy, returns undefined if the path element don't exists in the \n\t *         object hierarchy.\n\t */\n\tfunction digPath(facts, path, create) {\n\t    var hierarchy = path.split(/\\//g);\n\t    var heap = [facts];\n\t    var root = facts;\n\t    var factFullName = \"\";\n\t    while (hierarchy.length > 1) {\n\t        var name = hierarchy.shift();\n\t        if (name === \"..\") {\n\t            if (heap.length !== 0) {\n\t                heap.pop();\n\t                if (heap.length === 0) {\n\t                    root = facts;\n\t                } else {\n\t                    root = heap[heap.length - 1];\n\t                }\n\t            }\n\t        } else if (name !== \"\") {\n\t            factFullName += \"/\" + name;\n\t            if (!root[name]) {\n\t                if (!create) {\n\t                    return undefined;\n\t                } else {\n\t                    root[name] = {};\n\t                }\n\t            }\n\t            root = root[name]\n\t            heap.push(root);\n\t        }\n\t    }\n\t    return {\n\t        data: heap.pop(),\n\t        name: hierarchy[0],\n\t        fullName: factFullName + \"/\" + hierarchy[0]\n\t    };\n\t}\n\t\n\t\n\tfunction getContext(currentContext, path) {\n\t    var fullName = getFullName(currentContext, path);\n\t    var lastSlash = fullName.lastIndexOf(\"/\");\n\t    return fullName.substring(0, lastSlash + 1);\n\t}\n\t\n\tfunction getFullName(context, path) {\n\t    \n\t    if (!context || context.indexOf(\"/\") !== 0) {\n\t        throw new Error(\"context must start with a '/'. Value: '\" + \n\t            context + \"'\");\n\t    }\n\t    \n\t    if (path.indexOf(\"/\") === 0) {\n\t        // Since \"path\" starts with a '/' means that \"path\" is absolute. We \n\t        // don't care about the context in that case.\n\t        return getFullName(path, \"\");\n\t    }\n\t\n\t    var contextArray = context.split(\"/\");\n\t    var pathArray = path.split(\"/\");\n\t    var contextStack = contextArray.concat(pathArray);\n\t\n\t    // Here, \"contextStack\" should contains an array of all elements in the \n\t    // path. We expect \"contextStack[0]\" to contains an empty string. That\n\t    // empty string represents the root of the path and must be there.\n\t\n\t    var stack = [];\n\t    for (var i = 0; i < contextStack.length; i++) {\n\t        var contextPart = contextStack[i];\n\t        if (i === 0 || contextPart !== \"\") {    \n\t            // Keeps initial empty contextPart (root) and skip subsequent empty\n\t            // contextStack. This will make path like \"/a/b//c\" into \"/a/b/c\".\n\t            if (contextPart === \"..\") {\n\t                if (stack.length > 1) {\n\t                    stack.pop();\n\t                }\n\t            } else {\n\t                stack.push(contextPart);\n\t            }\n\t        }\n\t    }\n\t\n\t    var fullName = \"\";\n\t    for (var i = 0; i < stack.length; i++) {\n\t        if (i > 0) {\n\t            fullName += \"/\";\n\t        }\n\t        fullName += stack[i];\n\t    }\n\t\n\t    return fullName;\n\t}\n\t\n\t\n\tfunction deepCopy(target, source) {\n\t    var sourceType = typeof source;\n\t    if (sourceType !== \"object\") {\n\t        return deepCopy({}, target);\n\t    }\n\t    if (sourceType !== \"object\" || (source instanceof Date)) {\n\t        throw new Error(\"The 'source' parameter must be an object.\");\n\t    }\n\t    for (var property in source) {\n\t        var propertyType = typeof source[property];\n\t        if ((propertyType === \"object\") &&\n\t                (source[property] !== null) &&\n\t                !(source[property] instanceof Date) &&\n\t                !(source[property] instanceof Array)) {\n\t            target[property] = target[property] || {};\n\t            deepCopy(target[property], source[property]);\n\t        } else if (propertyType !== \"function\") {\n\t            target[property] = source[property];\n\t        }\n\t    }\n\t    return target;\n\t}\n\t\n\t\n\tfunction equals(a, b) {\n\t    var aValue = a;\n\t    if (a instanceof Date) {\n\t        aValue = a.getTime(); \n\t    }\n\t    var bValue = b;\n\t    if (b instanceof Date) {\n\t        bValue = b.getTime();\n\t    }\n\t    return (aValue === bValue) && ((typeof a) === (typeof b));\n\t}\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {\"use strict\";\n\t\n\tvar utils = __webpack_require__(3);\n\t\n\t\n\tmodule.exports = EngineProxy;\n\t\n\t/**\n\t * Creates an engine proxy class to hold a rule context of execution.\n\t * @class\n\t * @param {InfernalEngine} engine - The engine being proxied.\n\t * @param {string} - the rule name that will execute under the EngineProxy \n\t *                   context.\n\t */\n\tfunction EngineProxy(engine, ruleName) {\n\t    this.engine = engine;\n\t    this.ruleName = ruleName;\n\t    this.context = utils.getContext(\"/\", ruleName);\n\t}\n\t\n\t\n\t/**\n\t * Gets the fact value for the given factName. Note that the factName can be \n\t * a relative path to the current rule context. Usage of \"..\" allows to go\n\t * up the context stack to reach parents and sibling facts.\n\t *\n\t * @param {string} factName - The fact name.\n\t * \n\t * @returns {*} The fact value.\n\t */\n\tEngineProxy.prototype.get = function(factName) {\n\t    var fullFactName = utils.getFullName(this.context, factName);\n\t    return this.engine.get(fullFactName);\n\t};\n\t\n\t\n\t/**\n\t * Sets a fact value for the given fact name. The fact name can be a relative \n\t * path. See {@link EngineProxy#get} for details.\n\t *\n\t * @oaram {string} factName - the fact name.\n\t * @param {*} value - The value to set to the fact.\n\t *\n\t * @returns {EngineProxy} A reference to \"this\" object for method chaining.\n\t */\n\tEngineProxy.prototype.set = function(factName, value) {\n\t    var fullFactName = utils.getFullName(this.context, factName);\n\t    var oldValue = this.engine.get(fullFactName);\n\t    this.engine.set(fullFactName, value);\n\t\n\t    if ((typeof this.engine._trace === \"function\") && !utils.equals(oldValue, value)) {\n\t        var self = this;\n\t        process.nextTick(function() {\n\t            self.engine._trace({\n\t                action: \"set\",\n\t                rule: self.ruleName,\n\t                fact: fullFactName,\n\t                oldValue: oldValue,\n\t                newValue: value\n\t            });\n\t        });\n\t    }\n\t\n\t    return this;\n\t};\n\t\n\t/**\n\t * Notifies that the given fact has changed. The fact name can be a relative \n\t * path. See {@link EngineProxy#get} for details.\n\t *\n\t * @param {string} factName - The fact name.\n\t *\n\t * @returns {EngineProxy} A reference to \"this\" object for method chaining.\n\t */\n\tEngineProxy.prototype.notify = function(factName) {\n\t    var fullFactName = utils.getFullName(this.context, factName);\n\t    this.engine.notify(fullFactName);\n\t    return this;\n\t};\n\t\n\t\n\t/**\n\t * This method sends a trace message to the tracing function, if tracing \n\t * is activated.\n\t *\n\t * @param {string} message - The message to send to the trace function.\n\t *\n\t * @returns {EngineProxy} A reference to \"this\" object for method chaining.\n\t */\n\tEngineProxy.prototype.trace = function(message) {\n\t    if (typeof this.engine._trace === \"function\") {\n\t        var self = this;\n\t        process.nextTick(function() {\n\t            self.engine._trace({\n\t                action: \"trace\",\n\t                rule: self.ruleName,\n\t                message: message\n\t            });\n\t        });\n\t    }\n\t    return this;\n\t}\n\t\n\t\n\t// private\n\tEngineProxy.prototype._executeRule = function(callback) {\n\t   this.engine._rules[this.ruleName].call(this, callback);\n\t   return this;\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** infernal-engine.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap b4012e7b42b1be86f0d1\n **/","/**\n * Main module of the library, defines the class InfernalEngine and its\n * private methods.\n * Module infernal-engine\n */\n\n\"use strict\";\n\nvar Agenda      = require(\"./agenda\");\nvar utils       = require(\"./utils\");\nvar EngineProxy = require(\"./engine-proxy\");\n\nmodule.exports = InfernalEngine;\n\n\n/**\n * InfernalEngine class constructor.\n * @class\n *\n * @param {number} [timeout=5000] - How long the inference can take before\n *        the inference callback is called with a timeout error.\n *\n * @property {number} timeout - The timeout value in milliseconds set by the \n *                              constructor.\n */\nfunction InfernalEngine(timeout) {\n    this._facts     = {}; // Graph of facts\n    this._rules     = {}; // Map between rule names and rules (function)\n    this._relations = {}; // Map between fact names and all related rules\n    this._diffFacts = null; // A map of fact names that changed\n    this._trace     = null; // the tracing function\n    this._agenda    = new Agenda();\n    this._infering  = false;\n\n    this.timeout    = 5000;\n\n    if (timeout) {\n        this.timeout = timeout;\n    }\n}\n\n/**\n * Resets the engine to its inintial state. Do not change timeout value \n * nor the tracer function.\n */\nInfernalEngine.prototype.reset = function() {\n    this._facts     = {};\n    this._rules     = {};\n    this._relations = {};\n    this._diffFacts = null;\n    this._agenda    = new Agenda();\n    this._infering  = false;\n    if (typeof this._trace === \"function\") {\n        process.nextTick((function() {\n            this._trace({action: \"reset\"});\n        }).bind(this));\n    }\n};\n\n/**\n * Gets a value of the given factName. A factName is made of a context and \n * the fact simple name separated by '/'. Accessing a fact from the engine\n * assumes the context to be \"/\". Within a rule, the context\n * would be the same as the rule context.\n * \n * @param {string} factName - The fact name.\n * @returns {*} the fact value.\n */\nInfernalEngine.prototype.get = function(factName) {\n    if (factName.charAt(0) !== \"/\") {\n        return this.get(\"/\" + factName);\n    }\n\n    var fact = utils.digPath.call(this, this._facts, factName);\n    if (fact === undefined) {\n        return undefined;\n    }\n\n    return fact.data[fact.name];\n};\n\n\n/**\n * Sets a fact value for the given factName.\n *\n * @param {string} factName - The fact name.\n * @param {*} value - The fact value to be set.\n */\nInfernalEngine.prototype.set = function(factName, value) {\n   \n    if (factName.charAt(0) !== \"/\") {\n        return this.set(\"/\" + factName, value);\n    }\n\n    var oldValue = this.get(factName);\n    if (!utils.equals(oldValue, value)) {\n        var fact = utils.digPath.call(this, this._facts, factName, true);\n        \n        if (this._diffFacts) {\n            this._diffFacts[fact.fullName] = true;\n        }\n        \n        var oldValue = fact.data[fact.name];\n        fact.data[fact.name] = value;\n        \n        updateAgenda.call(this, factName);\n\n        if ((typeof this._trace === \"function\") && !this._infering) {\n            process.nextTick((function() {\n                this._trace({\n                    action: \"set\",\n                    fact: factName,\n                    oldValue: oldValue,\n                    newValue: value\n                });\n            }).bind(this));\n        }\n    }\n\n    return this;\n};\n\n\n/**\n * Notifies the engine to consider the given factName was updated. This method\n * is usefull when changing the content of an array without changing the array\n * reference.\n *\n * @param {string} factName - The fact name that have to be considered \n *                            changed by the engine.\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\n */\nInfernalEngine.prototype.notify = function(factName) {\n    if (factName.charAt(0) !== \"/\") {\n        return this.notify(\"/\" + factName, value);\n    }\n    updateAgenda.call(this, factName);\n    if ((typeof this._trace === \"function\") && !this._infering) {\n        process.nextTick((function() {\n            this._trace({\n                action: \"notify\",\n                fact: factName,\n                newValue: value\n            });\n        }).bind(this));\n    }\n    return this;\n};\n\n\n/**\n * Adds a rule to the engine.\n * \n * @param {string} ruleName\n *        The rule name, each segment separated by a '/'. A rule name cannot\n *        ends with '/'.\n *\n * @param {rule} rule \n *        The rule function has only one paramter: the 'done' function. When\n *        the rule evaluation is terminated, the done function must be called\n *        to tell the engine to execute the next rule in the agenda.\n *\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\n */\nInfernalEngine.prototype.addRule = function(ruleName, rule) {\n    if (typeof ruleName === \"function\") {\n        rule = ruleName;\n        ruleName = \"/\" + rule.name;\n    }\n    \n    if (ruleName.indexOf(\"/\") !== 0) {\n        ruleName = \"/\" + ruleName;\n    }\n    \n    var ruleContent = rule.toString();\n    var regex = /this\\.get\\([\"']?(.*?)[\"']?\\)/gm;\n    var match = regex.exec(ruleContent);\n    var factName;\n    this._rules[ruleName] = rule;\n\n    while (match) {\n        var context = utils.getContext(\"/\", ruleName);\n        factName = utils.getFullName(context, match[1]);\n        if (this._relations[factName] === undefined) {\n            this._relations[factName] = {};\n        }\n        this._relations[factName][ruleName] = true;\n        match = regex.exec(ruleContent);\n    }\n\n    if (typeof this._trace === \"function\") {\n        this._trace({action: \"addRule\", rule: ruleName});\n    }\n\n    return this;\n};\n\n\n/**\n * Gets the subset of facts that changed during the last call to infer().\n *\n * @returns {object} an object containing all facts that changed during the \n *                   last inference.\n */\nInfernalEngine.prototype.getDiff = function() {\n    var diff = {};\n    for (var factName in this._diffFacts) {\n        var fact = utils.digPath(diff, factName, true);\n        fact.data[fact.name] = this.get(factName);\n    }\n    return diff;\n};\n\n\n/**\n * Gets a deep copy of the internal facts object. When a fact contains an \n * array, that array reference is kept in the returned object. Modifying \n * that array would result in modifying the original array from the internal\n * facts.\n * \n * @returns {object} a deep copy of the internal facts.\n */\nInfernalEngine.prototype.getFacts = function() {\n    return utils.deepCopy(this._facts);\n};\n\n/**\n * Sets the internal facts to the values received in the facts parameter. The \n * internal facts reference is not changed to the object received. Instead,\n * the object tree is is read and each fact it contains are \"set\" so that any\n * changes to the actual internal fact values will trigger rules as required. \n * Functions are ingnored by that operation.\n *\n * @param {object} An object tree used to update internal facts.\n *\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\n */\nInfernalEngine.prototype.setFacts = function(facts) {\n    applyFacts.call(this, \"\", facts)\n    return this;\n};\n\n/**\n * Loads a model into the engine. This operation resets the engine and loads\n * that model's properties as facts and methods as rules.\n *\n * @param {object} model - A model object containing facts and rules.\n *\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\n */\nInfernalEngine.prototype.load = function(model) {\n    this.reset();\n    applyFacts.call(this, \"\", model, true);\n    return this;\n};\n\n\n/**\n * Starts the inference. The inference executes all rules in the agenda. Once\n * the inference is done, either because the agenda is empty or becaus the \n * inference timeout is reached, the callback method is called.\n *\n * @param {number} [timeout=InfernalEngine#timeout] The timeout period in \n *        milliseconds given to the infer call.\n *\n * @param {inferenceCallback} callback - The function to be executed when done.\n *\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\n */\nInfernalEngine.prototype.infer = function(timeout, callback) {\n    if (typeof timeout === \"function\") {\n        var actualCallback = timeout;\n        this.infer(this.timeout, actualCallback);\n        return;\n    }\n\n    if (this._agenda.isEmpty()) {\n        this._infering = false;\n        clearTimeout(this.timeoutId);\n        callback();\n        return;\n    }\n\n    if (timeout > 0 ) {\n        this._infering = true;\n        this._diffFacts = {};\n        this.timeoutId = setTimeout((function() {\n            this._infering = false;\n            callback(new Error( \n                \"Inference timed out after \" + timeout + \" ms\"));\n            return;\n        }).bind(this), timeout);\n        if (typeof this._trace === \"function\") {\n            process.nextTick((function() {\n                this._trace({action: \"infer\"});\n            }).bind(this));\n        }\n    }\n\n    if (this._infering === false) {\n        callback(new Error(\"The timeout parameter must be grater than zero \" +\n            \"to start infering.\"));\n        return;\n    }\n\n    var proxy = this._agenda.shift();\n    \n    process.nextTick((function() {\n        proxy._executeRule((function(err) {\n            if(err) {\n                this._infering = false;\n                clearTimeout(this.timeoutId);\n                callback(err);\n                return;\n            }\n            if (this._infering) {\n                this.infer(0, callback);\n            }\n        }).bind(this));\n    }).bind(this));\n\n    return this;\n};\n\n\n/**\n * Starts tracing the engine's operations.\n * @param {traceCallback} traceFunction The function called when an event\n *        is taking place. Events that generate a traceFunction call are:\n *        {@link InferenceEngine#reset}, \n *        {@link InferenceEngine#set},\n *        {@link InferenceEngine#notify},\n *        {@link InferenceEngine#addRule},\n *        {@link InferenceEngine#infer} and\n *        {@link EngineProxy#trace}.\n *\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\n */\nInfernalEngine.prototype.startTracing = function(traceFunction) {\n    if (!traceFunction) {\n        throw new Error(\"The parameter 'traceFunction' is mandatory.\");\n    }\n    this._trace = traceFunction;\n    return this;\n};\n\n/**\n * Stops calling any trace callback that could have been defined. Has no \n * effect if startStracing wasn't called before.\n *\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\n */\nInfernalEngine.prototype.stopTracing = function() {\n    this._trace = null;\n    return this;\n};\n\n\n\n// Private\n\nfunction applyFacts(context, source, loading) {\n    var sourceType = typeof source;\n    if ((sourceType === \"object\") && (source instanceof Date)) {\n        sourceType = \"date\";\n    }\n    \n    if ((sourceType === \"object\") && (source instanceof Array)) {\n        sourceType = \"array\";\n    }\n    \n    if (sourceType === \"function\") {\n        if (!loading) {\n            return;\n        } else {\n            this.addRule(context, source);\n        }\n\n    } else if (sourceType === \"object\") {\n        for (var property in source) {\n            applyFacts.call(this, context + \"/\" + property, source[property], loading);\n        }\n\n    } else {\n        this.set(context, source);\n    }\n}\n\n\nfunction updateAgenda(factName) {\n    if (this._relations[factName] !== undefined) {\n        var rules = this._relations[factName];\n        for (var ruleName in rules) {\n            if (rules.hasOwnProperty(ruleName) && \n                    (typeof this._agenda[ruleName] === \"undefined\")) {\n                this._agenda[ruleName] = new EngineProxy(this, ruleName);\n            }\n        }\n    }\n}\n\n\n/**\n * The inference callback function.\n * @callback inferenceCallback\n * @param {Error|*} [err] - The error information if something wrong happened.\n */\n\n\n/**\n * The done function tells the inference engine that the current rule is \n * terminated and that the next rule shall be executed. If no more rule are in\n * the agenda, the {@link inferenceCallback} function is called without any \n * parameter. If the done function is called with a parameter, the inference \n * immediately stops (no more rules are executed from the agenda) and the \n * {@link inferenceCallback} is called with the same parameter (the error).\n *\n * @callback done\n * @param {Error|*} [err] - The error information to send to the \n *        {@link inferenceCallback}\n */\n\n\n/**\n * The rule callback is a function that takes a single {@link done} callback \n * method. This method is executed in the context of an {@link EngineProxy} \n * instance. It is important to note that before exiting a rule function, the\n * done callback function has to be called to inform the engine that the next\n * rule in the agenda has to be executed. Usually after calling the done \n * function the method should exits by explicitely calling 'return' or by \n * letting the execution exit the scope of the function.\n *\n * @callback rule\n * @this EngineProxy\n * @param {done} done - The done callback to call when the rule terminate\n *                      execution.\n */\n\n /**\n  * The trace callback is called when an event changing the engine state is \n  * hapenning. See {@link InfernalEngine#startTracing} for details.\n  *\n  * @callback traceCallback\n  * @param {object} trace - The trace data.\n  * @param {string} trace#action - Can be either 'reset', 'set', 'notify', \n  *                                'addRule', 'infer' or 'trace'.\n  * @param {string} [trace#rule] - The rule name that generated the trace. This\n  *                                property is undefined if the trace was not\n  *                                generated during inference.\n  * @param {string} [trace#fact] - The fact name if the trace action is 'set' \n  *                                or 'notify'.\n  * @param {*} [trace#oldValue]  - The previous value of the fact if the trace\n  *                                action is 'set'.\n  * @param {*} [trace#newValue]  - The new value of the fact if trace action \n  *                                is 'set' or 'notify'.\n  * @param {string} [trace#message] - The message sent by the \n  *                                {@ling EngineProxy#trace} method if trace\n  *                                action is 'trace'.\n  */\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/index.js\n ** module id = 0\n ** module chunks = 0 1\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/process/browser.js\n ** module id = 1\n ** module chunks = 0 1\n **/","/**\n * Module agenda\n */\n\n\"use strict\";\n\nmodule.exports = Agenda;\n\n/**\n * Create an empty Agenda.\n * @class\n */\nfunction Agenda() {\n}\n\n\n/**\n * Removes the first element from the agenda and returns it.\n * \n * @returns {EngineProxy} - The next EngineProxy to be executed.\n */\nAgenda.prototype.shift = function() {\n    for (var key in this) {\n        if (key !== \"shift\" && key !== \"isEmpty\") {\n            var exec = this[key];\n            delete this[key];\n            return exec;\n        }\n    }\n}\n\n/**\n * Tells if the agenda is empty.\n *\n * @returns {boolean} True if the agenda is empty, false otherwise.\n */\nAgenda.prototype.isEmpty = function() {\n    for (var key in this) {\n        if (key !== \"shift\" && key !== \"isEmpty\") {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/agenda.js\n ** module id = 2\n ** module chunks = 0 1\n **/","\"use strict\";\n\nexports.digPath     = digPath;\nexports.getContext  = getContext;\nexports.getFullName = getFullName;\nexports.deepCopy    = deepCopy;\nexports.equals      = equals;\n\n\n/*\n * Dig a path in a root object until it finds the property that contains the \n * leaf element of the path.\n *\n * @param root   The root object to dig into\n * @param path   The path formatted with forward slashes. Supports \"..\" to move \n *               up one object in the hierarchy.\n * @param create If set to true, create the object tree while digging instead \n *               of returning undefined when encountering an undefined path \n *               element.\n * \n * @return The last object in the path along with the target leaf name in an \n *         object having these two properties: 'target', 'name'. If create is\n *         falsy, returns undefined if the path element don't exists in the \n *         object hierarchy.\n */\nfunction digPath(facts, path, create) {\n    var hierarchy = path.split(/\\//g);\n    var heap = [facts];\n    var root = facts;\n    var factFullName = \"\";\n    while (hierarchy.length > 1) {\n        var name = hierarchy.shift();\n        if (name === \"..\") {\n            if (heap.length !== 0) {\n                heap.pop();\n                if (heap.length === 0) {\n                    root = facts;\n                } else {\n                    root = heap[heap.length - 1];\n                }\n            }\n        } else if (name !== \"\") {\n            factFullName += \"/\" + name;\n            if (!root[name]) {\n                if (!create) {\n                    return undefined;\n                } else {\n                    root[name] = {};\n                }\n            }\n            root = root[name]\n            heap.push(root);\n        }\n    }\n    return {\n        data: heap.pop(),\n        name: hierarchy[0],\n        fullName: factFullName + \"/\" + hierarchy[0]\n    };\n}\n\n\nfunction getContext(currentContext, path) {\n    var fullName = getFullName(currentContext, path);\n    var lastSlash = fullName.lastIndexOf(\"/\");\n    return fullName.substring(0, lastSlash + 1);\n}\n\nfunction getFullName(context, path) {\n    \n    if (!context || context.indexOf(\"/\") !== 0) {\n        throw new Error(\"context must start with a '/'. Value: '\" + \n            context + \"'\");\n    }\n    \n    if (path.indexOf(\"/\") === 0) {\n        // Since \"path\" starts with a '/' means that \"path\" is absolute. We \n        // don't care about the context in that case.\n        return getFullName(path, \"\");\n    }\n\n    var contextArray = context.split(\"/\");\n    var pathArray = path.split(\"/\");\n    var contextStack = contextArray.concat(pathArray);\n\n    // Here, \"contextStack\" should contains an array of all elements in the \n    // path. We expect \"contextStack[0]\" to contains an empty string. That\n    // empty string represents the root of the path and must be there.\n\n    var stack = [];\n    for (var i = 0; i < contextStack.length; i++) {\n        var contextPart = contextStack[i];\n        if (i === 0 || contextPart !== \"\") {    \n            // Keeps initial empty contextPart (root) and skip subsequent empty\n            // contextStack. This will make path like \"/a/b//c\" into \"/a/b/c\".\n            if (contextPart === \"..\") {\n                if (stack.length > 1) {\n                    stack.pop();\n                }\n            } else {\n                stack.push(contextPart);\n            }\n        }\n    }\n\n    var fullName = \"\";\n    for (var i = 0; i < stack.length; i++) {\n        if (i > 0) {\n            fullName += \"/\";\n        }\n        fullName += stack[i];\n    }\n\n    return fullName;\n}\n\n\nfunction deepCopy(target, source) {\n    var sourceType = typeof source;\n    if (sourceType !== \"object\") {\n        return deepCopy({}, target);\n    }\n    if (sourceType !== \"object\" || (source instanceof Date)) {\n        throw new Error(\"The 'source' parameter must be an object.\");\n    }\n    for (var property in source) {\n        var propertyType = typeof source[property];\n        if ((propertyType === \"object\") &&\n                (source[property] !== null) &&\n                !(source[property] instanceof Date) &&\n                !(source[property] instanceof Array)) {\n            target[property] = target[property] || {};\n            deepCopy(target[property], source[property]);\n        } else if (propertyType !== \"function\") {\n            target[property] = source[property];\n        }\n    }\n    return target;\n}\n\n\nfunction equals(a, b) {\n    var aValue = a;\n    if (a instanceof Date) {\n        aValue = a.getTime(); \n    }\n    var bValue = b;\n    if (b instanceof Date) {\n        bValue = b.getTime();\n    }\n    return (aValue === bValue) && ((typeof a) === (typeof b));\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/utils.js\n ** module id = 3\n ** module chunks = 0 1\n **/","\"use strict\";\n\nvar utils = require(\"./utils\");\n\n\nmodule.exports = EngineProxy;\n\n/**\n * Creates an engine proxy class to hold a rule context of execution.\n * @class\n * @param {InfernalEngine} engine - The engine being proxied.\n * @param {string} - the rule name that will execute under the EngineProxy \n *                   context.\n */\nfunction EngineProxy(engine, ruleName) {\n    this.engine = engine;\n    this.ruleName = ruleName;\n    this.context = utils.getContext(\"/\", ruleName);\n}\n\n\n/**\n * Gets the fact value for the given factName. Note that the factName can be \n * a relative path to the current rule context. Usage of \"..\" allows to go\n * up the context stack to reach parents and sibling facts.\n *\n * @param {string} factName - The fact name.\n * \n * @returns {*} The fact value.\n */\nEngineProxy.prototype.get = function(factName) {\n    var fullFactName = utils.getFullName(this.context, factName);\n    return this.engine.get(fullFactName);\n};\n\n\n/**\n * Sets a fact value for the given fact name. The fact name can be a relative \n * path. See {@link EngineProxy#get} for details.\n *\n * @oaram {string} factName - the fact name.\n * @param {*} value - The value to set to the fact.\n *\n * @returns {EngineProxy} A reference to \"this\" object for method chaining.\n */\nEngineProxy.prototype.set = function(factName, value) {\n    var fullFactName = utils.getFullName(this.context, factName);\n    var oldValue = this.engine.get(fullFactName);\n    this.engine.set(fullFactName, value);\n\n    if ((typeof this.engine._trace === \"function\") && !utils.equals(oldValue, value)) {\n        var self = this;\n        process.nextTick(function() {\n            self.engine._trace({\n                action: \"set\",\n                rule: self.ruleName,\n                fact: fullFactName,\n                oldValue: oldValue,\n                newValue: value\n            });\n        });\n    }\n\n    return this;\n};\n\n/**\n * Notifies that the given fact has changed. The fact name can be a relative \n * path. See {@link EngineProxy#get} for details.\n *\n * @param {string} factName - The fact name.\n *\n * @returns {EngineProxy} A reference to \"this\" object for method chaining.\n */\nEngineProxy.prototype.notify = function(factName) {\n    var fullFactName = utils.getFullName(this.context, factName);\n    this.engine.notify(fullFactName);\n    return this;\n};\n\n\n/**\n * This method sends a trace message to the tracing function, if tracing \n * is activated.\n *\n * @param {string} message - The message to send to the trace function.\n *\n * @returns {EngineProxy} A reference to \"this\" object for method chaining.\n */\nEngineProxy.prototype.trace = function(message) {\n    if (typeof this.engine._trace === \"function\") {\n        var self = this;\n        process.nextTick(function() {\n            self.engine._trace({\n                action: \"trace\",\n                rule: self.ruleName,\n                message: message\n            });\n        });\n    }\n    return this;\n}\n\n\n// private\nEngineProxy.prototype._executeRule = function(callback) {\n   this.engine._rules[this.ruleName].call(this, callback);\n   return this;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/engine-proxy.js\n ** module id = 4\n ** module chunks = 0 1\n **/"],"sourceRoot":""}