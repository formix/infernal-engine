{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///infernal-engine.min.js","webpack:///webpack/bootstrap f39b6dc4dc5e7da853ae?a9c2","webpack:///./lib/index.js?bdd8","webpack:///(webpack)/~/node-libs-browser/~/process/browser.js?6f0e","webpack:///./lib/agenda.js?7b45","webpack:///./lib/utils.js?cd26","webpack:///./lib/engine-proxy.js?257d"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","process","InfernalEngine","timeout","_facts","_rules","_relations","_changes","_trace","_agenda","Agenda","_infering","applyFacts","context","source","loading","sourceType","Date","Array","addRule","property","set","updateAgenda","factName","undefined","rules","ruleName","hasOwnProperty","EngineProxy","utils","prototype","reset","nextTick","action","bind","get","charAt","fact","digPath","data","name","value","callback","oldValue","equals","fullName","newValue","infer","err","getChanges","notify","rule","indexOf","ruleContent","toString","regex","match","exec","getContext","getFullName","getDiff","diff","deepCopy","getFacts","setFacts","facts","load","model","actualCallback","isEmpty","clearTimeout","timeoutId","setTimeout","Error","proxy","shift","_executeRule","startTracing","traceFunction","stopTracing","cleanUpNextTick","draining","currentQueue","length","queue","concat","queueIndex","drainQueue","len","run","Item","fun","array","noop","args","arguments","i","push","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","umask","key","path","create","hierarchy","split","heap","factFullName","pop","currentContext","lastSlash","lastIndexOf","substring","contextArray","pathArray","contextStack","stack","contextPart","target","propertyType","a","b","aValue","getTime","bValue","engine","fullFactName","self","trace","message"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,UAAAH,GACA,gBAAAC,SACAA,QAAA,eAAAD,IAEAD,EAAA,eAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDgBM,SAASL,EAAQD,EAASM,IEtDhC,SAAAS,GAMA,YAmBA,SAAAC,GAAAC,GACAb,KAAAc,UACAd,KAAAe,UACAf,KAAAgB,cACAhB,KAAAiB,SAAA,KACAjB,KAAAkB,OAAA,KACAlB,KAAAmB,QAAA,GAAAC,GACApB,KAAAqB,WAAA,EAEArB,KAAAa,QAAA,IAEAA,IACAb,KAAAa,WA2VA,QAAAS,GAAAC,EAAAC,EAAAC,GACA,GAAAC,SAAAF,EASA,IARA,WAAAE,GAAAF,YAAAG,QACAD,EAAA,QAGA,WAAAA,GAAAF,YAAAI,SACAF,EAAA,SAGA,aAAAA,EAAA,CACA,IAAAD,EACA,MAEAzB,MAAA6B,QAAAN,EAAAC,OAGK,eAAAE,EACL,OAAAI,KAAAN,GACAF,EAAAf,KAAAP,KAAAuB,EAAA,IAAAO,EAAAN,EAAAM,GAAAL,OAIAzB,MAAA+B,IAAAR,EAAAC,GAKA,QAAAQ,GAAAC,GACA,GAAAC,SAAAlC,KAAAgB,WAAAiB,GAAA,CACA,GAAAE,GAAAnC,KAAAgB,WAAAiB,EACA,QAAAG,KAAAD,GACAA,EAAAE,eAAAD,IACA,mBAAApC,MAAAmB,QAAAiB,KACApC,KAAAmB,QAAAiB,GAAA,GAAAE,GAAAtC,KAAAoC,KA1ZA,GAAAhB,GAAAlB,EAAA,GACAqC,EAAArC,EAAA,GACAoC,EAAApC,EAAA,EAEAL,GAAAD,QAAAgB,EAiCAA,EAAA4B,UAAAC,MAAA,WACAzC,KAAAc,UACAd,KAAAe,UACAf,KAAAgB,cACAhB,KAAAiB,SAAA,KACAjB,KAAAmB,QAAA,GAAAC,GACApB,KAAAqB,WAAA,EACA,kBAAArB,MAAAkB,QACAP,EAAA+B,SAAA,WACA1C,KAAAkB,QAAyByB,OAAA,WAChBC,KAAA5C,QAaTY,EAAA4B,UAAAK,IAAA,SAAAZ,GACA,SAAAA,EAAAa,OAAA,GACA,MAAA9C,MAAA6C,IAAA,IAAAZ,EAGA,IAAAc,GAAAR,EAAAS,QAAAzC,KAAAP,UAAAc,OAAAmB,EACA,IAAAC,SAAAa,EAIA,MAAAA,GAAAE,KAAAF,EAAAG,OAaAtC,EAAA4B,UAAAT,IAAA,SAAAE,EAAAkB,EAAAC,GAEA,SAAAnB,EAAAa,OAAA,GACA,MAAA9C,MAAA+B,IAAA,IAAAE,EAAAkB,EAAAC,EAGA,IAAAC,GAAArD,KAAA6C,IAAAZ,EACA,KAAAM,EAAAe,OAAAD,EAAAF,GAAA,CACA,GAAAJ,GAAAR,EAAAS,QAAAzC,KAAAP,UAAAc,OAAAmB,GAAA,EAEAjC,MAAAiB,WACAjB,KAAAiB,SAAA8B,EAAAQ,UAAAJ,EAGA,IAAAE,GAAAN,EAAAE,KAAAF,EAAAG,KACAH,GAAAE,KAAAF,EAAAG,MAAAC,EAEAnB,EAAAzB,KAAAP,KAAAiC,GAEA,kBAAAjC,MAAAkB,QAAAlB,KAAAqB,WACAV,EAAA+B,SAAA,WACA1C,KAAAkB,QACAyB,OAAA,MACAI,KAAAd,EACAoB,WACAG,SAAAL,KAEaP,KAAA5C,OAGboD,GACApD,KAAAyD,MAAA,SAAAC,GACA,MAAAA,OACAN,GAAAM,OAGAN,GAAA,KAAApD,KAAA2D,eACaf,KAAA5C,OAIb,MAAAA,OAaAY,EAAA4B,UAAAoB,OAAA,SAAA3B,GACA,YAAAA,EAAAa,OAAA,GACA9C,KAAA4D,OAAA,IAAA3B,EAAAkB,QAEAnB,EAAAzB,KAAAP,KAAAiC,GACA,kBAAAjC,MAAAkB,QAAAlB,KAAAqB,WACAV,EAAA+B,SAAA,WACA1C,KAAAkB,QACAyB,OAAA,SACAI,KAAAd,EACAuB,SAAAL,SAESP,KAAA5C,OAETA,OAkBAY,EAAA4B,UAAAX,QAAA,SAAAO,EAAAyB,GACA,kBAAAzB,KACAyB,EAAAzB,EACAA,EAAA,IAAAyB,EAAAX,MAGA,IAAAd,EAAA0B,QAAA,OACA1B,EAAA,IAAAA,EAGA,IAGAH,GAHA8B,EAAAF,EAAAG,WACAC,EAAA,iCACAC,EAAAD,EAAAE,KAAAJ,EAIA,KAFA/D,KAAAe,OAAAqB,GAAAyB,EAEAK,GAAA,CACA,GAAA3C,GAAAgB,EAAA6B,WAAA,IAAAhC,EACAH,GAAAM,EAAA8B,YAAA9C,EAAA2C,EAAA,IACAhC,SAAAlC,KAAAgB,WAAAiB,KACAjC,KAAAgB,WAAAiB,OAEAjC,KAAAgB,WAAAiB,GAAAG,IAAA,EACA8B,EAAAD,EAAAE,KAAAJ,GAOA,MAJA,kBAAA/D,MAAAkB,QACAlB,KAAAkB,QAAqByB,OAAA,UAAAkB,KAAAzB,IAGrBpC,MAUAY,EAAA4B,UAAA8B,QAAA,WACA,GAAAC,KACA,QAAAtC,KAAAjC,MAAAiB,SAAA,CACA,GAAA8B,GAAAR,EAAAS,QAAAuB,EAAAtC,GAAA,EACAc,GAAAE,KAAAF,EAAAG,MAAAlD,KAAA6C,IAAAZ,GAEA,MAAAsC,IAUA3D,EAAA4B,UAAAmB,WAAA,WACA,MAAApB,GAAAiC,SAAAxE,KAAAiB,WAWAL,EAAA4B,UAAAiC,SAAA,WACA,MAAAlC,GAAAiC,SAAAxE,KAAAc,SAcAF,EAAA4B,UAAAkC,SAAA,SAAAC,GAEA,MADArD,GAAAf,KAAAP,KAAA,GAAA2E,GACA3E,MAWAY,EAAA4B,UAAAoC,KAAA,SAAAC,GAGA,MAFA7E,MAAAyC,QACAnB,EAAAf,KAAAP,KAAA,GAAA6E,GAAA,GACA7E,MAgBAY,EAAA4B,UAAAiB,MAAA,SAAA5C,EAAAuC,GACA,qBAAAvC,GAAA,CACA,GAAAiE,GAAAjE,CAEA,YADAb,MAAAyD,MAAAzD,KAAAa,QAAAiE,GAIA,GAAA9E,KAAAmB,QAAA4D,UAIA,MAHA/E,MAAAqB,WAAA,EACA2D,aAAAhF,KAAAiF,eACA7B,IAoBA,IAhBAvC,EAAA,IACAb,KAAAqB,WAAA,EACArB,KAAAiB,YACAjB,KAAAiF,UAAAC,WAAA,WACAlF,KAAAqB,WAAA,EACA+B,EAAA,GAAA+B,OACA,6BAAAtE,EAAA,SAES+B,KAAA5C,MAAAa,GACT,kBAAAb,MAAAkB,QACAP,EAAA+B,SAAA,WACA1C,KAAAkB,QAA6ByB,OAAA,WAChBC,KAAA5C,QAIbA,KAAAqB,aAAA,EAGA,WAFA+B,GAAA,GAAA+B,OAAA,qEAKA,IAAAC,GAAApF,KAAAmB,QAAAkE,OAgBA,OAdA1E,GAAA+B,SAAA,WACA0C,EAAAE,aAAA,SAAA5B,GACA,MAAAA,IACA1D,KAAAqB,WAAA,EACA2D,aAAAhF,KAAAiF,eACA7B,GAAAM,SAGA1D,KAAAqB,WACArB,KAAAyD,MAAA,EAAAL,KAESR,KAAA5C,QACJ4C,KAAA5C,OAELA,MAiBAY,EAAA4B,UAAA+C,aAAA,SAAAC,GACA,IAAAA,EACA,SAAAL,OAAA,8CAGA,OADAnF,MAAAkB,OAAAsE,EACAxF,MASAY,EAAA4B,UAAAiD,YAAA,WAEA,MADAzF,MAAAkB,OAAA,KACAlB,QFkK8BO,KAAKX,EAASM,EAAoB,KAI1D,SAASL,EAAQD,GGvhBvB,QAAA8F,KACAC,GAAA,EACAC,EAAAC,OACAC,EAAAF,EAAAG,OAAAD,GAEAE,EAAA,GAEAF,EAAAD,QACAI,IAIA,QAAAA,KACA,IAAAN,EAAA,CAGA,GAAA9E,GAAAqE,WAAAQ,EACAC,IAAA,CAGA,KADA,GAAAO,GAAAJ,EAAAD,OACAK,GAAA,CAGA,IAFAN,EAAAE,EACAA,OACAE,EAAAE,GACAN,GACAA,EAAAI,GAAAG,KAGAH,GAAA,GACAE,EAAAJ,EAAAD,OAEAD,EAAA,KACAD,GAAA,EACAX,aAAAnE,IAiBA,QAAAuF,GAAAC,EAAAC,GACAtG,KAAAqG,MACArG,KAAAsG,QAYA,QAAAC,MAtEA,GAGAX,GAHAjF,EAAAd,EAAAD,WACAkG,KACAH,GAAA,EAEAK,EAAA,EAsCArF,GAAA+B,SAAA,SAAA2D,GACA,GAAAG,GAAA,GAAA5E,OAAA6E,UAAAZ,OAAA,EACA,IAAAY,UAAAZ,OAAA,EACA,OAAAa,GAAA,EAAuBA,EAAAD,UAAAZ,OAAsBa,IAC7CF,EAAAE,EAAA,GAAAD,UAAAC,EAGAZ,GAAAa,KAAA,GAAAP,GAAAC,EAAAG,IACA,IAAAV,EAAAD,QAAAF,GACAT,WAAAe,EAAA,IASAG,EAAA5D,UAAA2D,IAAA,WACAnG,KAAAqG,IAAAO,MAAA,KAAA5G,KAAAsG,QAEA3F,EAAAkG,MAAA,UACAlG,EAAAmG,SAAA,EACAnG,EAAAoG,OACApG,EAAAqG,QACArG,EAAAsG,QAAA,GACAtG,EAAAuG,YAIAvG,EAAAwG,GAAAZ,EACA5F,EAAAyG,YAAAb,EACA5F,EAAA0G,KAAAd,EACA5F,EAAA2G,IAAAf,EACA5F,EAAA4G,eAAAhB,EACA5F,EAAA6G,mBAAAjB,EACA5F,EAAA8G,KAAAlB,EAEA5F,EAAA+G,QAAA,SAAAxE,GACA,SAAAiC,OAAA,qCAGAxE,EAAAgH,IAAA,WAA2B,WAC3BhH,EAAAiH,MAAA,SAAAC,GACA,SAAA1C,OAAA,mCAEAxE,EAAAmH,MAAA,WAA4B,WHsiBtB,SAASjI,EAAQD,GI5nBvB,YAQA,SAAAwB,MANAvB,EAAAD,QAAAwB,EAeAA,EAAAoB,UAAA6C,MAAA,WACA,OAAA0C,KAAA/H,MACA,aAAA+H,GAAA,YAAAA,EAAA,CACA,GAAA5D,GAAAnE,KAAA+H,EAEA,cADA/H,MAAA+H,GACA5D,IAUA/C,EAAAoB,UAAAuC,QAAA,WACA,OAAAgD,KAAA/H,MACA,aAAA+H,GAAA,YAAAA,EACA,QAGA,YJwoBM,SAASlI,EAAQD,GKlrBvB,YAyBA,SAAAoD,GAAA2B,EAAAqD,EAAAC,GAKA,IAJA,GAAAC,GAAAF,EAAAG,MAAA,OACAC,GAAAzD,GACAjF,EAAAiF,EACA0D,EAAA,GACAH,EAAArC,OAAA,IACA,GAAA3C,GAAAgF,EAAA7C,OACA,WAAAnC,EACA,IAAAkF,EAAAvC,SACAuC,EAAAE,MAEA5I,EADA,IAAA0I,EAAAvC,OACAlB,EAEAyD,IAAAvC,OAAA,QAGS,SAAA3C,EAAA,CAET,GADAmF,GAAA,IAAAnF,GACAxD,EAAAwD,GAAA,CACA,IAAA+E,EACA,MAEAvI,GAAAwD,MAGAxD,IAAAwD,GACAkF,EAAAzB,KAAAjH,IAGA,OACAuD,KAAAmF,EAAAE,MACApF,KAAAgF,EAAA,GACA3E,SAAA8E,EAAA,IAAAH,EAAA,IAKA,QAAA9D,GAAAmE,EAAAP,GACA,GAAAzE,GAAAc,EAAAkE,EAAAP,GACAQ,EAAAjF,EAAAkF,YAAA,IACA,OAAAlF,GAAAmF,UAAA,EAAAF,EAAA,GAGA,QAAAnE,GAAA9C,EAAAyG,GAEA,IAAAzG,GAAA,IAAAA,EAAAuC,QAAA,KACA,SAAAqB,OAAA,0CACA5D,EAAA,IAGA,QAAAyG,EAAAlE,QAAA,KAGA,MAAAO,GAAA2D,EAAA,GAYA,QATAW,GAAApH,EAAA4G,MAAA,KACAS,EAAAZ,EAAAG,MAAA,KACAU,EAAAF,EAAA5C,OAAA6C,GAMAE,KACApC,EAAA,EAAmBA,EAAAmC,EAAAhD,OAAyBa,IAAA,CAC5C,GAAAqC,GAAAF,EAAAnC,EACA,KAAAA,GAAA,KAAAqC,IAGA,OAAAA,EACAD,EAAAjD,OAAA,GACAiD,EAAAR,MAGAQ,EAAAnC,KAAAoC,IAMA,OADAxF,GAAA,GACAmD,EAAA,EAAmBA,EAAAoC,EAAAjD,OAAkBa,IACrCA,EAAA,IACAnD,GAAA,KAEAA,GAAAuF,EAAApC,EAGA,OAAAnD,GAIA,QAAAiB,GAAAwE,EAAAxH,GACA,GAAAE,SAAAF,EACA,eAAAE,EACA,MAAA8C,MAA0BwE,EAE1B,eAAAtH,GAAAF,YAAAG,MACA,SAAAwD,OAAA,4CAEA,QAAArD,KAAAN,GAAA,CACA,GAAAyH,SAAAzH,GAAAM,EACA,YAAAmH,GACA,OAAAzH,EAAAM,IACAN,EAAAM,YAAAH,OACAH,EAAAM,YAAAF,OAGS,aAAAqH,IACTD,EAAAlH,GAAAN,EAAAM,KAHAkH,EAAAlH,GAAAkH,EAAAlH,OACA0C,EAAAwE,EAAAlH,GAAAN,EAAAM,KAKA,MAAAkH,GAIA,QAAA1F,GAAA4F,EAAAC,GACA,GAAAC,GAAAF,CACAA,aAAAvH,QACAyH,EAAAF,EAAAG,UAEA,IAAAC,GAAAH,CAIA,OAHAA,aAAAxH,QACA2H,EAAAH,EAAAE,WAEAD,IAAAE,SAAAJ,UAAAC,GApJAvJ,EAAAoD,UACApD,EAAAwE,aACAxE,EAAAyE,cACAzE,EAAA4E,WACA5E,EAAA0D,UL00BM,SAASzD,EAAQD,EAASM,IMh1BhC,SAAAS,GAAA,YAcA,SAAA2B,GAAAiH,EAAAnH,GACApC,KAAAuJ,SACAvJ,KAAAoC,WACApC,KAAAuB,QAAAgB,EAAA6B,WAAA,IAAAhC,GAfA,GAAAG,GAAArC,EAAA,EAGAL,GAAAD,QAAA0C,EAyBAA,EAAAE,UAAAK,IAAA,SAAAZ,GACA,GAAAuH,GAAAjH,EAAA8B,YAAArE,KAAAuB,QAAAU,EACA,OAAAjC,MAAAuJ,OAAA1G,IAAA2G,IAaAlH,EAAAE,UAAAT,IAAA,SAAAE,EAAAkB,GACA,GAAAqG,GAAAjH,EAAA8B,YAAArE,KAAAuB,QAAAU,GACAoB,EAAArD,KAAAuJ,OAAA1G,IAAA2G,EAGA,IAFAxJ,KAAAuJ,OAAAxH,IAAAyH,EAAArG,GAEA,kBAAAnD,MAAAuJ,OAAArI,SAAAqB,EAAAe,OAAAD,EAAAF,GAAA,CACA,GAAAsG,GAAAzJ,IACAW,GAAA+B,SAAA,WACA+G,EAAAF,OAAArI,QACAyB,OAAA,MACAkB,KAAA4F,EAAArH,SACAW,KAAAyG,EACAnG,WACAG,SAAAL,MAKA,MAAAnD,OAWAsC,EAAAE,UAAAoB,OAAA,SAAA3B,GACA,GAAAuH,GAAAjH,EAAA8B,YAAArE,KAAAuB,QAAAU,EAEA,OADAjC,MAAAuJ,OAAA3F,OAAA4F,GACAxJ,MAYAsC,EAAAE,UAAAkH,MAAA,SAAAC,GACA,qBAAA3J,MAAAuJ,OAAArI,OAAA,CACA,GAAAuI,GAAAzJ,IACAW,GAAA+B,SAAA,WACA+G,EAAAF,OAAArI,QACAyB,OAAA,QACAkB,KAAA4F,EAAArH,SACAuH,cAIA,MAAA3J,OAKAsC,EAAAE,UAAA8C,aAAA,SAAAlC,GAEA,MADApD,MAAAuJ,OAAAxI,OAAAf,KAAAoC,UAAA7B,KAAAP,KAAAoD,GACApD,QNq1B8BO,KAAKX,EAASM,EAAoB","file":"infernal-engine.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"InfernalEngine\"] = factory();\n\telse\n\t\troot[\"InfernalEngine\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"InfernalEngine\"] = factory();\n\telse\n\t\troot[\"InfernalEngine\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {/**\r\n\t * Main module of the library, defines the class InfernalEngine and its\r\n\t * private methods.\r\n\t * Module infernal-engine\r\n\t */\r\n\t\r\n\t\"use strict\";\r\n\t\r\n\tvar Agenda      = __webpack_require__(2);\r\n\tvar utils       = __webpack_require__(3);\r\n\tvar EngineProxy = __webpack_require__(4);\r\n\t\r\n\tmodule.exports = InfernalEngine;\r\n\t\r\n\t\r\n\t/**\r\n\t * InfernalEngine class constructor.\r\n\t * @class\r\n\t *\r\n\t * @param {number} [timeout=5000] - How long the inference can take before\r\n\t *        the inference callback is called with a timeout error.\r\n\t *\r\n\t * @property {number} timeout - The timeout value in milliseconds set by the \r\n\t *                              constructor.\r\n\t */\r\n\tfunction InfernalEngine(timeout) {\r\n\t    this._facts     = {}; // Graph of facts\r\n\t    this._rules     = {}; // Map between rule names and rules (function)\r\n\t    this._relations = {}; // Map between fact names and all related rules\r\n\t    this._changes   = null; // A map of fact names that changed\r\n\t    this._trace     = null; // the tracing function\r\n\t    this._agenda    = new Agenda();\r\n\t    this._infering  = false;\r\n\t\r\n\t    this.timeout    = 5000;\r\n\t\r\n\t    if (timeout) {\r\n\t        this.timeout = timeout;\r\n\t    }\r\n\t}\r\n\t\r\n\t/**\r\n\t * Resets the engine to its inintial state. Do not change timeout value \r\n\t * nor the tracer function.\r\n\t */\r\n\tInfernalEngine.prototype.reset = function() {\r\n\t    this._facts     = {};\r\n\t    this._rules     = {};\r\n\t    this._relations = {};\r\n\t    this._changes   = null;\r\n\t    this._agenda    = new Agenda();\r\n\t    this._infering  = false;\r\n\t    if (typeof this._trace === \"function\") {\r\n\t        process.nextTick((function() {\r\n\t            this._trace({action: \"reset\"});\r\n\t        }).bind(this));\r\n\t    }\r\n\t};\r\n\t\r\n\t/**\r\n\t * Gets a value of the given factName. A factName is made of a context and \r\n\t * the fact simple name separated by '/'. Accessing a fact from the engine\r\n\t * assumes the context to be \"/\". Within a rule, the context\r\n\t * would be the same as the rule context.\r\n\t * \r\n\t * @param {string} factName - The fact name.\r\n\t * @returns {*} the fact value.\r\n\t */\r\n\tInfernalEngine.prototype.get = function(factName) {\r\n\t    if (factName.charAt(0) !== \"/\") {\r\n\t        return this.get(\"/\" + factName);\r\n\t    }\r\n\t\r\n\t    var fact = utils.digPath.call(this, this._facts, factName);\r\n\t    if (fact === undefined) {\r\n\t        return undefined;\r\n\t    }\r\n\t\r\n\t    return fact.data[fact.name];\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Sets a fact value for the given factName.\r\n\t *\r\n\t * @param {string} factName - The fact name.\r\n\t * @param {*} value - The fact value to be set.\r\n\t * @param {function} [callback] - \r\n\t *        The callback(err, changes). Tha changes object is a mapping between\r\n\t *        every fact names and their final value.\r\n\t */\r\n\tInfernalEngine.prototype.set = function(factName, value, callback) {\r\n\t   \r\n\t    if (factName.charAt(0) !== \"/\") {\r\n\t        return this.set(\"/\" + factName, value, callback);\r\n\t    }\r\n\t\r\n\t    var oldValue = this.get(factName);\r\n\t    if (!utils.equals(oldValue, value)) {\r\n\t        var fact = utils.digPath.call(this, this._facts, factName, true);\r\n\t        \r\n\t        if (this._changes) {\r\n\t            this._changes[fact.fullName] = value;\r\n\t        }\r\n\t\r\n\t        var oldValue = fact.data[fact.name];\r\n\t        fact.data[fact.name] = value;\r\n\t        \r\n\t        updateAgenda.call(this, factName);\r\n\t\r\n\t        if ((typeof this._trace === \"function\") && !this._infering) {\r\n\t            process.nextTick((function() {\r\n\t                this._trace({\r\n\t                    action: \"set\",\r\n\t                    fact: factName,\r\n\t                    oldValue: oldValue,\r\n\t                    newValue: value\r\n\t                });\r\n\t            }).bind(this));\r\n\t        }\r\n\t\r\n\t        if (callback) {\r\n\t            this.infer((function(err) {\r\n\t                if (err) {\r\n\t                    callback(err);\r\n\t                    return;\r\n\t                }\r\n\t                callback(null, this.getChanges());\r\n\t            }).bind(this));\r\n\t        }\r\n\t    }\r\n\t\r\n\t    return this;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Notifies the engine to consider the given factName was updated. This method\r\n\t * is usefull when changing the content of an array without changing the array\r\n\t * reference.\r\n\t *\r\n\t * @param {string} factName - The fact name that have to be considered \r\n\t *                            changed by the engine.\r\n\t * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\r\n\t */\r\n\tInfernalEngine.prototype.notify = function(factName) {\r\n\t    if (factName.charAt(0) !== \"/\") {\r\n\t        return this.notify(\"/\" + factName, value);\r\n\t    }\r\n\t    updateAgenda.call(this, factName);\r\n\t    if ((typeof this._trace === \"function\") && !this._infering) {\r\n\t        process.nextTick((function() {\r\n\t            this._trace({\r\n\t                action: \"notify\",\r\n\t                fact: factName,\r\n\t                newValue: value\r\n\t            });\r\n\t        }).bind(this));\r\n\t    }\r\n\t    return this;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Adds a rule to the engine.\r\n\t * \r\n\t * @param {string} ruleName\r\n\t *        The rule name, each segment separated by a '/'. A rule name cannot\r\n\t *        ends with '/'.\r\n\t *\r\n\t * @param {rule} rule \r\n\t *        The rule function has only one paramter: the 'done' function. When\r\n\t *        the rule evaluation is terminated, the done function must be called\r\n\t *        to tell the engine to execute the next rule in the agenda.\r\n\t *\r\n\t * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\r\n\t */\r\n\tInfernalEngine.prototype.addRule = function(ruleName, rule) {\r\n\t    if (typeof ruleName === \"function\") {\r\n\t        rule = ruleName;\r\n\t        ruleName = \"/\" + rule.name;\r\n\t    }\r\n\t    \r\n\t    if (ruleName.indexOf(\"/\") !== 0) {\r\n\t        ruleName = \"/\" + ruleName;\r\n\t    }\r\n\t    \r\n\t    var ruleContent = rule.toString();\r\n\t    var regex = /this\\.get\\([\"']?(.*?)[\"']?\\)/gm;\r\n\t    var match = regex.exec(ruleContent);\r\n\t    var factName;\r\n\t    this._rules[ruleName] = rule;\r\n\t\r\n\t    while (match) {\r\n\t        var context = utils.getContext(\"/\", ruleName);\r\n\t        factName = utils.getFullName(context, match[1]);\r\n\t        if (this._relations[factName] === undefined) {\r\n\t            this._relations[factName] = {};\r\n\t        }\r\n\t        this._relations[factName][ruleName] = true;\r\n\t        match = regex.exec(ruleContent);\r\n\t    }\r\n\t\r\n\t    if (typeof this._trace === \"function\") {\r\n\t        this._trace({action: \"addRule\", rule: ruleName});\r\n\t    }\r\n\t\r\n\t    return this;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Gets the subset of facts that changed during the last call to infer().\r\n\t *\r\n\t * @returns {object} an object containing all facts that changed during the \r\n\t *                   last inference.\r\n\t */\r\n\tInfernalEngine.prototype.getDiff = function() {\r\n\t    var diff = {};\r\n\t    for (var factName in this._changes) {\r\n\t        var fact = utils.digPath(diff, factName, true);\r\n\t        fact.data[fact.name] = this.get(factName);\r\n\t    }\r\n\t    return diff;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Gets an object mapping the fact full name to the last change the given\r\n\t * fact got through.\r\n\t *\r\n\t * @returns {object} A map of fact paths and their corresponding values.\r\n\t */\r\n\tInfernalEngine.prototype.getChanges = function() {\r\n\t    return utils.deepCopy(this._changes);\r\n\t};\r\n\t\r\n\t/**\r\n\t * Gets a deep copy of the internal facts object. When a fact contains an \r\n\t * array, that array reference is kept in the returned object. Modifying \r\n\t * that array would result in modifying the original array from the internal\r\n\t * facts.\r\n\t * \r\n\t * @returns {object} a deep copy of the internal facts.\r\n\t */\r\n\tInfernalEngine.prototype.getFacts = function() {\r\n\t    return utils.deepCopy(this._facts);\r\n\t};\r\n\t\r\n\t/**\r\n\t * Sets the internal facts to the values received in the facts parameter. The \r\n\t * internal facts reference is not changed to the object received. Instead,\r\n\t * the object tree is is read and each fact it contains are \"set\" so that any\r\n\t * changes to the actual internal fact values will trigger rules as required. \r\n\t * Functions are ingnored by that operation.\r\n\t *\r\n\t * @param {object} An object tree used to update internal facts.\r\n\t *\r\n\t * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\r\n\t */\r\n\tInfernalEngine.prototype.setFacts = function(facts) {\r\n\t    applyFacts.call(this, \"\", facts)\r\n\t    return this;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Loads a model into the engine. This operation resets the engine and loads\r\n\t * that model's properties as facts and methods as rules.\r\n\t *\r\n\t * @param {object} model - A model object containing facts and rules.\r\n\t *\r\n\t * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\r\n\t */\r\n\tInfernalEngine.prototype.load = function(model) {\r\n\t    this.reset();\r\n\t    applyFacts.call(this, \"\", model, true);\r\n\t    return this;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Starts the inference. The inference executes all rules in the agenda. Once\r\n\t * the inference is done, either because the agenda is empty or becaus the \r\n\t * inference timeout is reached, the callback method is called.\r\n\t *\r\n\t * @param {number} [timeout=InfernalEngine#timeout] The timeout period in \r\n\t *        milliseconds given to the infer call.\r\n\t *\r\n\t * @param {inferenceCallback} callback - The function to be executed when done.\r\n\t *\r\n\t * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\r\n\t */\r\n\tInfernalEngine.prototype.infer = function(timeout, callback) {\r\n\t    if (typeof timeout === \"function\") {\r\n\t        var actualCallback = timeout;\r\n\t        this.infer(this.timeout, actualCallback);\r\n\t        return;\r\n\t    }\r\n\t\r\n\t    if (this._agenda.isEmpty()) {\r\n\t        this._infering = false;\r\n\t        clearTimeout(this.timeoutId);\r\n\t        callback();\r\n\t        return;\r\n\t    }\r\n\t\r\n\t    if (timeout > 0 ) {\r\n\t        this._infering = true;\r\n\t        this._changes = {};\r\n\t        this.timeoutId = setTimeout((function() {\r\n\t            this._infering = false;\r\n\t            callback(new Error( \r\n\t                \"Inference timed out after \" + timeout + \" ms\"));\r\n\t            return;\r\n\t        }).bind(this), timeout);\r\n\t        if (typeof this._trace === \"function\") {\r\n\t            process.nextTick((function() {\r\n\t                this._trace({action: \"infer\"});\r\n\t            }).bind(this));\r\n\t        }\r\n\t    }\r\n\t\r\n\t    if (this._infering === false) {\r\n\t        callback(new Error(\"The timeout parameter must be grater than zero \" +\r\n\t            \"to start infering.\"));\r\n\t        return;\r\n\t    }\r\n\t\r\n\t    var proxy = this._agenda.shift();\r\n\t    \r\n\t    process.nextTick((function() {\r\n\t        proxy._executeRule((function(err) {\r\n\t            if(err) {\r\n\t                this._infering = false;\r\n\t                clearTimeout(this.timeoutId);\r\n\t                callback(err);\r\n\t                return;\r\n\t            }\r\n\t            if (this._infering) {\r\n\t                this.infer(0, callback);\r\n\t            }\r\n\t        }).bind(this));\r\n\t    }).bind(this));\r\n\t\r\n\t    return this;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Starts tracing the engine's operations.\r\n\t * @param {traceCallback} traceFunction The function called when an event\r\n\t *        is taking place. Events that generate a traceFunction call are:\r\n\t *        {@link InferenceEngine#reset}, \r\n\t *        {@link InferenceEngine#set},\r\n\t *        {@link InferenceEngine#notify},\r\n\t *        {@link InferenceEngine#addRule},\r\n\t *        {@link InferenceEngine#infer} and\r\n\t *        {@link EngineProxy#trace}.\r\n\t *\r\n\t * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\r\n\t */\r\n\tInfernalEngine.prototype.startTracing = function(traceFunction) {\r\n\t    if (!traceFunction) {\r\n\t        throw new Error(\"The parameter 'traceFunction' is mandatory.\");\r\n\t    }\r\n\t    this._trace = traceFunction;\r\n\t    return this;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Stops calling any trace callback that could have been defined. Has no \r\n\t * effect if startStracing wasn't called before.\r\n\t *\r\n\t * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\r\n\t */\r\n\tInfernalEngine.prototype.stopTracing = function() {\r\n\t    this._trace = null;\r\n\t    return this;\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\t// Private\r\n\t\r\n\tfunction applyFacts(context, source, loading) {\r\n\t    var sourceType = typeof source;\r\n\t    if ((sourceType === \"object\") && (source instanceof Date)) {\r\n\t        sourceType = \"date\";\r\n\t    }\r\n\t    \r\n\t    if ((sourceType === \"object\") && (source instanceof Array)) {\r\n\t        sourceType = \"array\";\r\n\t    }\r\n\t    \r\n\t    if (sourceType === \"function\") {\r\n\t        if (!loading) {\r\n\t            return;\r\n\t        } else {\r\n\t            this.addRule(context, source);\r\n\t        }\r\n\t\r\n\t    } else if (sourceType === \"object\") {\r\n\t        for (var property in source) {\r\n\t            applyFacts.call(this, context + \"/\" + property, source[property], loading);\r\n\t        }\r\n\t\r\n\t    } else {\r\n\t        this.set(context, source);\r\n\t    }\r\n\t}\r\n\t\r\n\t\r\n\tfunction updateAgenda(factName) {\r\n\t    if (this._relations[factName] !== undefined) {\r\n\t        var rules = this._relations[factName];\r\n\t        for (var ruleName in rules) {\r\n\t            if (rules.hasOwnProperty(ruleName) && \r\n\t                    (typeof this._agenda[ruleName] === \"undefined\")) {\r\n\t                this._agenda[ruleName] = new EngineProxy(this, ruleName);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * The inference callback function.\r\n\t * @callback inferenceCallback\r\n\t * @param {Error|*} [err] - The error information if something wrong happened.\r\n\t */\r\n\t\r\n\t\r\n\t/**\r\n\t * The done function tells the inference engine that the current rule is \r\n\t * terminated and that the next rule shall be executed. If no more rule are in\r\n\t * the agenda, the {@link inferenceCallback} function is called without any \r\n\t * parameter. If the done function is called with a parameter, the inference \r\n\t * immediately stops (no more rules are executed from the agenda) and the \r\n\t * {@link inferenceCallback} is called with the same parameter (the error).\r\n\t *\r\n\t * @callback done\r\n\t * @param {Error|*} [err] - The error information to send to the \r\n\t *        {@link inferenceCallback}\r\n\t */\r\n\t\r\n\t\r\n\t/**\r\n\t * The rule callback is a function that takes a single {@link done} callback \r\n\t * method. This method is executed in the context of an {@link EngineProxy} \r\n\t * instance. It is important to note that before exiting a rule function, the\r\n\t * done callback function has to be called to inform the engine that the next\r\n\t * rule in the agenda has to be executed. Usually after calling the done \r\n\t * function the method should exits by explicitely calling 'return' or by \r\n\t * letting the execution exit the scope of the function.\r\n\t *\r\n\t * @callback rule\r\n\t * @this EngineProxy\r\n\t * @param {done} done - The done callback to call when the rule terminate\r\n\t *                      execution.\r\n\t */\r\n\t\r\n\t /**\r\n\t  * The trace callback is called when an event changing the engine state is \r\n\t  * hapenning. See {@link InfernalEngine#startTracing} for details.\r\n\t  *\r\n\t  * @callback traceCallback\r\n\t  * @param {object} trace - The trace data.\r\n\t  * @param {string} trace#action - Can be either 'reset', 'set', 'notify', \r\n\t  *                                'addRule', 'infer' or 'trace'.\r\n\t  * @param {string} [trace#rule] - The rule name that generated the trace. This\r\n\t  *                                property is undefined if the trace was not\r\n\t  *                                generated during inference.\r\n\t  * @param {string} [trace#fact] - The fact name if the trace action is 'set' \r\n\t  *                                or 'notify'.\r\n\t  * @param {*} [trace#oldValue]  - The previous value of the fact if the trace\r\n\t  *                                action is 'set'.\r\n\t  * @param {*} [trace#newValue]  - The new value of the fact if trace action \r\n\t  *                                is 'set' or 'notify'.\r\n\t  * @param {string} [trace#message] - The message sent by the \r\n\t  *                                {@ling EngineProxy#trace} method if trace\r\n\t  *                                action is 'trace'.\r\n\t  */\r\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * Module agenda\r\n\t */\r\n\t\r\n\t\"use strict\";\r\n\t\r\n\tmodule.exports = Agenda;\r\n\t\r\n\t/**\r\n\t * Create an empty Agenda.\r\n\t * @class\r\n\t */\r\n\tfunction Agenda() {\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Removes the first element from the agenda and returns it.\r\n\t * \r\n\t * @returns {EngineProxy} - The next EngineProxy to be executed.\r\n\t */\r\n\tAgenda.prototype.shift = function() {\r\n\t    for (var key in this) {\r\n\t        if (key !== \"shift\" && key !== \"isEmpty\") {\r\n\t            var exec = this[key];\r\n\t            delete this[key];\r\n\t            return exec;\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\t/**\r\n\t * Tells if the agenda is empty.\r\n\t *\r\n\t * @returns {boolean} True if the agenda is empty, false otherwise.\r\n\t */\r\n\tAgenda.prototype.isEmpty = function() {\r\n\t    for (var key in this) {\r\n\t        if (key !== \"shift\" && key !== \"isEmpty\") {\r\n\t            return false;\r\n\t        }\r\n\t    }\r\n\t    return true;\r\n\t}\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\r\n\t\r\n\texports.digPath     = digPath;\r\n\texports.getContext  = getContext;\r\n\texports.getFullName = getFullName;\r\n\texports.deepCopy    = deepCopy;\r\n\texports.equals      = equals;\r\n\t\r\n\t\r\n\t/*\r\n\t * Dig a path in a root object until it finds the property that contains the \r\n\t * leaf element of the path.\r\n\t *\r\n\t * @param root   The root object to dig into\r\n\t * @param path   The path formatted with forward slashes. Supports \"..\" to move \r\n\t *               up one object in the hierarchy.\r\n\t * @param create If set to true, create the object tree while digging instead \r\n\t *               of returning undefined when encountering an undefined path \r\n\t *               element.\r\n\t * \r\n\t * @return The last object in the path along with the target leaf name in an \r\n\t *         object having these two properties: 'target', 'name'. If create is\r\n\t *         falsy, returns undefined if the path element don't exists in the \r\n\t *         object hierarchy.\r\n\t */\r\n\tfunction digPath(facts, path, create) {\r\n\t    var hierarchy = path.split(/\\//g);\r\n\t    var heap = [facts];\r\n\t    var root = facts;\r\n\t    var factFullName = \"\";\r\n\t    while (hierarchy.length > 1) {\r\n\t        var name = hierarchy.shift();\r\n\t        if (name === \"..\") {\r\n\t            if (heap.length !== 0) {\r\n\t                heap.pop();\r\n\t                if (heap.length === 0) {\r\n\t                    root = facts;\r\n\t                } else {\r\n\t                    root = heap[heap.length - 1];\r\n\t                }\r\n\t            }\r\n\t        } else if (name !== \"\") {\r\n\t            factFullName += \"/\" + name;\r\n\t            if (!root[name]) {\r\n\t                if (!create) {\r\n\t                    return undefined;\r\n\t                } else {\r\n\t                    root[name] = {};\r\n\t                }\r\n\t            }\r\n\t            root = root[name]\r\n\t            heap.push(root);\r\n\t        }\r\n\t    }\r\n\t    return {\r\n\t        data: heap.pop(),\r\n\t        name: hierarchy[0],\r\n\t        fullName: factFullName + \"/\" + hierarchy[0]\r\n\t    };\r\n\t}\r\n\t\r\n\t\r\n\tfunction getContext(currentContext, path) {\r\n\t    var fullName = getFullName(currentContext, path);\r\n\t    var lastSlash = fullName.lastIndexOf(\"/\");\r\n\t    return fullName.substring(0, lastSlash + 1);\r\n\t}\r\n\t\r\n\tfunction getFullName(context, path) {\r\n\t    \r\n\t    if (!context || context.indexOf(\"/\") !== 0) {\r\n\t        throw new Error(\"context must start with a '/'. Value: '\" + \r\n\t            context + \"'\");\r\n\t    }\r\n\t    \r\n\t    if (path.indexOf(\"/\") === 0) {\r\n\t        // Since \"path\" starts with a '/' means that \"path\" is absolute. We \r\n\t        // don't care about the context in that case.\r\n\t        return getFullName(path, \"\");\r\n\t    }\r\n\t\r\n\t    var contextArray = context.split(\"/\");\r\n\t    var pathArray = path.split(\"/\");\r\n\t    var contextStack = contextArray.concat(pathArray);\r\n\t\r\n\t    // Here, \"contextStack\" should contains an array of all elements in the \r\n\t    // path. We expect \"contextStack[0]\" to contains an empty string. That\r\n\t    // empty string represents the root of the path and must be there.\r\n\t\r\n\t    var stack = [];\r\n\t    for (var i = 0; i < contextStack.length; i++) {\r\n\t        var contextPart = contextStack[i];\r\n\t        if (i === 0 || contextPart !== \"\") {    \r\n\t            // Keeps initial empty contextPart (root) and skip subsequent empty\r\n\t            // contextStack. This will make path like \"/a/b//c\" into \"/a/b/c\".\r\n\t            if (contextPart === \"..\") {\r\n\t                if (stack.length > 1) {\r\n\t                    stack.pop();\r\n\t                }\r\n\t            } else {\r\n\t                stack.push(contextPart);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    var fullName = \"\";\r\n\t    for (var i = 0; i < stack.length; i++) {\r\n\t        if (i > 0) {\r\n\t            fullName += \"/\";\r\n\t        }\r\n\t        fullName += stack[i];\r\n\t    }\r\n\t\r\n\t    return fullName;\r\n\t}\r\n\t\r\n\t\r\n\tfunction deepCopy(target, source) {\r\n\t    var sourceType = typeof source;\r\n\t    if (sourceType !== \"object\") {\r\n\t        return deepCopy({}, target);\r\n\t    }\r\n\t    if (sourceType !== \"object\" || (source instanceof Date)) {\r\n\t        throw new Error(\"The 'source' parameter must be an object.\");\r\n\t    }\r\n\t    for (var property in source) {\r\n\t        var propertyType = typeof source[property];\r\n\t        if ((propertyType === \"object\") &&\r\n\t                (source[property] !== null) &&\r\n\t                !(source[property] instanceof Date) &&\r\n\t                !(source[property] instanceof Array)) {\r\n\t            target[property] = target[property] || {};\r\n\t            deepCopy(target[property], source[property]);\r\n\t        } else if (propertyType !== \"function\") {\r\n\t            target[property] = source[property];\r\n\t        }\r\n\t    }\r\n\t    return target;\r\n\t}\r\n\t\r\n\t\r\n\tfunction equals(a, b) {\r\n\t    var aValue = a;\r\n\t    if (a instanceof Date) {\r\n\t        aValue = a.getTime(); \r\n\t    }\r\n\t    var bValue = b;\r\n\t    if (b instanceof Date) {\r\n\t        bValue = b.getTime();\r\n\t    }\r\n\t    return (aValue === bValue) && ((typeof a) === (typeof b));\r\n\t}\r\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {\"use strict\";\r\n\t\r\n\tvar utils = __webpack_require__(3);\r\n\t\r\n\t\r\n\tmodule.exports = EngineProxy;\r\n\t\r\n\t/**\r\n\t * Creates an engine proxy class to hold a rule context of execution.\r\n\t * @class\r\n\t * @param {InfernalEngine} engine - The engine being proxied.\r\n\t * @param {string} - the rule name that will execute under the EngineProxy \r\n\t *                   context.\r\n\t */\r\n\tfunction EngineProxy(engine, ruleName) {\r\n\t    this.engine = engine;\r\n\t    this.ruleName = ruleName;\r\n\t    this.context = utils.getContext(\"/\", ruleName);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Gets the fact value for the given factName. Note that the factName can be \r\n\t * a relative path to the current rule context. Usage of \"..\" allows to go\r\n\t * up the context stack to reach parents and sibling facts.\r\n\t *\r\n\t * @param {string} factName - The fact name.\r\n\t * \r\n\t * @returns {*} The fact value.\r\n\t */\r\n\tEngineProxy.prototype.get = function(factName) {\r\n\t    var fullFactName = utils.getFullName(this.context, factName);\r\n\t    return this.engine.get(fullFactName);\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Sets a fact value for the given fact name. The fact name can be a relative \r\n\t * path. See {@link EngineProxy#get} for details.\r\n\t *\r\n\t * @oaram {string} factName - the fact name.\r\n\t * @param {*} value - The value to set to the fact.\r\n\t *\r\n\t * @returns {EngineProxy} A reference to \"this\" object for method chaining.\r\n\t */\r\n\tEngineProxy.prototype.set = function(factName, value) {\r\n\t    var fullFactName = utils.getFullName(this.context, factName);\r\n\t    var oldValue = this.engine.get(fullFactName);\r\n\t    this.engine.set(fullFactName, value);\r\n\t\r\n\t    if ((typeof this.engine._trace === \"function\") && !utils.equals(oldValue, value)) {\r\n\t        var self = this;\r\n\t        process.nextTick(function() {\r\n\t            self.engine._trace({\r\n\t                action: \"set\",\r\n\t                rule: self.ruleName,\r\n\t                fact: fullFactName,\r\n\t                oldValue: oldValue,\r\n\t                newValue: value\r\n\t            });\r\n\t        });\r\n\t    }\r\n\t\r\n\t    return this;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Notifies that the given fact has changed. The fact name can be a relative \r\n\t * path. See {@link EngineProxy#get} for details.\r\n\t *\r\n\t * @param {string} factName - The fact name.\r\n\t *\r\n\t * @returns {EngineProxy} A reference to \"this\" object for method chaining.\r\n\t */\r\n\tEngineProxy.prototype.notify = function(factName) {\r\n\t    var fullFactName = utils.getFullName(this.context, factName);\r\n\t    this.engine.notify(fullFactName);\r\n\t    return this;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * This method sends a trace message to the tracing function, if tracing \r\n\t * is activated.\r\n\t *\r\n\t * @param {string} message - The message to send to the trace function.\r\n\t *\r\n\t * @returns {EngineProxy} A reference to \"this\" object for method chaining.\r\n\t */\r\n\tEngineProxy.prototype.trace = function(message) {\r\n\t    if (typeof this.engine._trace === \"function\") {\r\n\t        var self = this;\r\n\t        process.nextTick(function() {\r\n\t            self.engine._trace({\r\n\t                action: \"trace\",\r\n\t                rule: self.ruleName,\r\n\t                message: message\r\n\t            });\r\n\t        });\r\n\t    }\r\n\t    return this;\r\n\t}\r\n\t\r\n\t\r\n\t// private\r\n\tEngineProxy.prototype._executeRule = function(callback) {\r\n\t   this.engine._rules[this.ruleName].call(this, callback);\r\n\t   return this;\r\n\t};\r\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** infernal-engine.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap f39b6dc4dc5e7da853ae\n **/","/**\r\n * Main module of the library, defines the class InfernalEngine and its\r\n * private methods.\r\n * Module infernal-engine\r\n */\r\n\r\n\"use strict\";\r\n\r\nvar Agenda      = require(\"./agenda\");\r\nvar utils       = require(\"./utils\");\r\nvar EngineProxy = require(\"./engine-proxy\");\r\n\r\nmodule.exports = InfernalEngine;\r\n\r\n\r\n/**\r\n * InfernalEngine class constructor.\r\n * @class\r\n *\r\n * @param {number} [timeout=5000] - How long the inference can take before\r\n *        the inference callback is called with a timeout error.\r\n *\r\n * @property {number} timeout - The timeout value in milliseconds set by the \r\n *                              constructor.\r\n */\r\nfunction InfernalEngine(timeout) {\r\n    this._facts     = {}; // Graph of facts\r\n    this._rules     = {}; // Map between rule names and rules (function)\r\n    this._relations = {}; // Map between fact names and all related rules\r\n    this._changes   = null; // A map of fact names that changed\r\n    this._trace     = null; // the tracing function\r\n    this._agenda    = new Agenda();\r\n    this._infering  = false;\r\n\r\n    this.timeout    = 5000;\r\n\r\n    if (timeout) {\r\n        this.timeout = timeout;\r\n    }\r\n}\r\n\r\n/**\r\n * Resets the engine to its inintial state. Do not change timeout value \r\n * nor the tracer function.\r\n */\r\nInfernalEngine.prototype.reset = function() {\r\n    this._facts     = {};\r\n    this._rules     = {};\r\n    this._relations = {};\r\n    this._changes   = null;\r\n    this._agenda    = new Agenda();\r\n    this._infering  = false;\r\n    if (typeof this._trace === \"function\") {\r\n        process.nextTick((function() {\r\n            this._trace({action: \"reset\"});\r\n        }).bind(this));\r\n    }\r\n};\r\n\r\n/**\r\n * Gets a value of the given factName. A factName is made of a context and \r\n * the fact simple name separated by '/'. Accessing a fact from the engine\r\n * assumes the context to be \"/\". Within a rule, the context\r\n * would be the same as the rule context.\r\n * \r\n * @param {string} factName - The fact name.\r\n * @returns {*} the fact value.\r\n */\r\nInfernalEngine.prototype.get = function(factName) {\r\n    if (factName.charAt(0) !== \"/\") {\r\n        return this.get(\"/\" + factName);\r\n    }\r\n\r\n    var fact = utils.digPath.call(this, this._facts, factName);\r\n    if (fact === undefined) {\r\n        return undefined;\r\n    }\r\n\r\n    return fact.data[fact.name];\r\n};\r\n\r\n\r\n/**\r\n * Sets a fact value for the given factName.\r\n *\r\n * @param {string} factName - The fact name.\r\n * @param {*} value - The fact value to be set.\r\n * @param {function} [callback] - \r\n *        The callback(err, changes). Tha changes object is a mapping between\r\n *        every fact names and their final value.\r\n */\r\nInfernalEngine.prototype.set = function(factName, value, callback) {\r\n   \r\n    if (factName.charAt(0) !== \"/\") {\r\n        return this.set(\"/\" + factName, value, callback);\r\n    }\r\n\r\n    var oldValue = this.get(factName);\r\n    if (!utils.equals(oldValue, value)) {\r\n        var fact = utils.digPath.call(this, this._facts, factName, true);\r\n        \r\n        if (this._changes) {\r\n            this._changes[fact.fullName] = value;\r\n        }\r\n\r\n        var oldValue = fact.data[fact.name];\r\n        fact.data[fact.name] = value;\r\n        \r\n        updateAgenda.call(this, factName);\r\n\r\n        if ((typeof this._trace === \"function\") && !this._infering) {\r\n            process.nextTick((function() {\r\n                this._trace({\r\n                    action: \"set\",\r\n                    fact: factName,\r\n                    oldValue: oldValue,\r\n                    newValue: value\r\n                });\r\n            }).bind(this));\r\n        }\r\n\r\n        if (callback) {\r\n            this.infer((function(err) {\r\n                if (err) {\r\n                    callback(err);\r\n                    return;\r\n                }\r\n                callback(null, this.getChanges());\r\n            }).bind(this));\r\n        }\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * Notifies the engine to consider the given factName was updated. This method\r\n * is usefull when changing the content of an array without changing the array\r\n * reference.\r\n *\r\n * @param {string} factName - The fact name that have to be considered \r\n *                            changed by the engine.\r\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\r\n */\r\nInfernalEngine.prototype.notify = function(factName) {\r\n    if (factName.charAt(0) !== \"/\") {\r\n        return this.notify(\"/\" + factName, value);\r\n    }\r\n    updateAgenda.call(this, factName);\r\n    if ((typeof this._trace === \"function\") && !this._infering) {\r\n        process.nextTick((function() {\r\n            this._trace({\r\n                action: \"notify\",\r\n                fact: factName,\r\n                newValue: value\r\n            });\r\n        }).bind(this));\r\n    }\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * Adds a rule to the engine.\r\n * \r\n * @param {string} ruleName\r\n *        The rule name, each segment separated by a '/'. A rule name cannot\r\n *        ends with '/'.\r\n *\r\n * @param {rule} rule \r\n *        The rule function has only one paramter: the 'done' function. When\r\n *        the rule evaluation is terminated, the done function must be called\r\n *        to tell the engine to execute the next rule in the agenda.\r\n *\r\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\r\n */\r\nInfernalEngine.prototype.addRule = function(ruleName, rule) {\r\n    if (typeof ruleName === \"function\") {\r\n        rule = ruleName;\r\n        ruleName = \"/\" + rule.name;\r\n    }\r\n    \r\n    if (ruleName.indexOf(\"/\") !== 0) {\r\n        ruleName = \"/\" + ruleName;\r\n    }\r\n    \r\n    var ruleContent = rule.toString();\r\n    var regex = /this\\.get\\([\"']?(.*?)[\"']?\\)/gm;\r\n    var match = regex.exec(ruleContent);\r\n    var factName;\r\n    this._rules[ruleName] = rule;\r\n\r\n    while (match) {\r\n        var context = utils.getContext(\"/\", ruleName);\r\n        factName = utils.getFullName(context, match[1]);\r\n        if (this._relations[factName] === undefined) {\r\n            this._relations[factName] = {};\r\n        }\r\n        this._relations[factName][ruleName] = true;\r\n        match = regex.exec(ruleContent);\r\n    }\r\n\r\n    if (typeof this._trace === \"function\") {\r\n        this._trace({action: \"addRule\", rule: ruleName});\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * Gets the subset of facts that changed during the last call to infer().\r\n *\r\n * @returns {object} an object containing all facts that changed during the \r\n *                   last inference.\r\n */\r\nInfernalEngine.prototype.getDiff = function() {\r\n    var diff = {};\r\n    for (var factName in this._changes) {\r\n        var fact = utils.digPath(diff, factName, true);\r\n        fact.data[fact.name] = this.get(factName);\r\n    }\r\n    return diff;\r\n};\r\n\r\n\r\n/**\r\n * Gets an object mapping the fact full name to the last change the given\r\n * fact got through.\r\n *\r\n * @returns {object} A map of fact paths and their corresponding values.\r\n */\r\nInfernalEngine.prototype.getChanges = function() {\r\n    return utils.deepCopy(this._changes);\r\n};\r\n\r\n/**\r\n * Gets a deep copy of the internal facts object. When a fact contains an \r\n * array, that array reference is kept in the returned object. Modifying \r\n * that array would result in modifying the original array from the internal\r\n * facts.\r\n * \r\n * @returns {object} a deep copy of the internal facts.\r\n */\r\nInfernalEngine.prototype.getFacts = function() {\r\n    return utils.deepCopy(this._facts);\r\n};\r\n\r\n/**\r\n * Sets the internal facts to the values received in the facts parameter. The \r\n * internal facts reference is not changed to the object received. Instead,\r\n * the object tree is is read and each fact it contains are \"set\" so that any\r\n * changes to the actual internal fact values will trigger rules as required. \r\n * Functions are ingnored by that operation.\r\n *\r\n * @param {object} An object tree used to update internal facts.\r\n *\r\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\r\n */\r\nInfernalEngine.prototype.setFacts = function(facts) {\r\n    applyFacts.call(this, \"\", facts)\r\n    return this;\r\n};\r\n\r\n/**\r\n * Loads a model into the engine. This operation resets the engine and loads\r\n * that model's properties as facts and methods as rules.\r\n *\r\n * @param {object} model - A model object containing facts and rules.\r\n *\r\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\r\n */\r\nInfernalEngine.prototype.load = function(model) {\r\n    this.reset();\r\n    applyFacts.call(this, \"\", model, true);\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * Starts the inference. The inference executes all rules in the agenda. Once\r\n * the inference is done, either because the agenda is empty or becaus the \r\n * inference timeout is reached, the callback method is called.\r\n *\r\n * @param {number} [timeout=InfernalEngine#timeout] The timeout period in \r\n *        milliseconds given to the infer call.\r\n *\r\n * @param {inferenceCallback} callback - The function to be executed when done.\r\n *\r\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\r\n */\r\nInfernalEngine.prototype.infer = function(timeout, callback) {\r\n    if (typeof timeout === \"function\") {\r\n        var actualCallback = timeout;\r\n        this.infer(this.timeout, actualCallback);\r\n        return;\r\n    }\r\n\r\n    if (this._agenda.isEmpty()) {\r\n        this._infering = false;\r\n        clearTimeout(this.timeoutId);\r\n        callback();\r\n        return;\r\n    }\r\n\r\n    if (timeout > 0 ) {\r\n        this._infering = true;\r\n        this._changes = {};\r\n        this.timeoutId = setTimeout((function() {\r\n            this._infering = false;\r\n            callback(new Error( \r\n                \"Inference timed out after \" + timeout + \" ms\"));\r\n            return;\r\n        }).bind(this), timeout);\r\n        if (typeof this._trace === \"function\") {\r\n            process.nextTick((function() {\r\n                this._trace({action: \"infer\"});\r\n            }).bind(this));\r\n        }\r\n    }\r\n\r\n    if (this._infering === false) {\r\n        callback(new Error(\"The timeout parameter must be grater than zero \" +\r\n            \"to start infering.\"));\r\n        return;\r\n    }\r\n\r\n    var proxy = this._agenda.shift();\r\n    \r\n    process.nextTick((function() {\r\n        proxy._executeRule((function(err) {\r\n            if(err) {\r\n                this._infering = false;\r\n                clearTimeout(this.timeoutId);\r\n                callback(err);\r\n                return;\r\n            }\r\n            if (this._infering) {\r\n                this.infer(0, callback);\r\n            }\r\n        }).bind(this));\r\n    }).bind(this));\r\n\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * Starts tracing the engine's operations.\r\n * @param {traceCallback} traceFunction The function called when an event\r\n *        is taking place. Events that generate a traceFunction call are:\r\n *        {@link InferenceEngine#reset}, \r\n *        {@link InferenceEngine#set},\r\n *        {@link InferenceEngine#notify},\r\n *        {@link InferenceEngine#addRule},\r\n *        {@link InferenceEngine#infer} and\r\n *        {@link EngineProxy#trace}.\r\n *\r\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\r\n */\r\nInfernalEngine.prototype.startTracing = function(traceFunction) {\r\n    if (!traceFunction) {\r\n        throw new Error(\"The parameter 'traceFunction' is mandatory.\");\r\n    }\r\n    this._trace = traceFunction;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Stops calling any trace callback that could have been defined. Has no \r\n * effect if startStracing wasn't called before.\r\n *\r\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\r\n */\r\nInfernalEngine.prototype.stopTracing = function() {\r\n    this._trace = null;\r\n    return this;\r\n};\r\n\r\n\r\n\r\n// Private\r\n\r\nfunction applyFacts(context, source, loading) {\r\n    var sourceType = typeof source;\r\n    if ((sourceType === \"object\") && (source instanceof Date)) {\r\n        sourceType = \"date\";\r\n    }\r\n    \r\n    if ((sourceType === \"object\") && (source instanceof Array)) {\r\n        sourceType = \"array\";\r\n    }\r\n    \r\n    if (sourceType === \"function\") {\r\n        if (!loading) {\r\n            return;\r\n        } else {\r\n            this.addRule(context, source);\r\n        }\r\n\r\n    } else if (sourceType === \"object\") {\r\n        for (var property in source) {\r\n            applyFacts.call(this, context + \"/\" + property, source[property], loading);\r\n        }\r\n\r\n    } else {\r\n        this.set(context, source);\r\n    }\r\n}\r\n\r\n\r\nfunction updateAgenda(factName) {\r\n    if (this._relations[factName] !== undefined) {\r\n        var rules = this._relations[factName];\r\n        for (var ruleName in rules) {\r\n            if (rules.hasOwnProperty(ruleName) && \r\n                    (typeof this._agenda[ruleName] === \"undefined\")) {\r\n                this._agenda[ruleName] = new EngineProxy(this, ruleName);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * The inference callback function.\r\n * @callback inferenceCallback\r\n * @param {Error|*} [err] - The error information if something wrong happened.\r\n */\r\n\r\n\r\n/**\r\n * The done function tells the inference engine that the current rule is \r\n * terminated and that the next rule shall be executed. If no more rule are in\r\n * the agenda, the {@link inferenceCallback} function is called without any \r\n * parameter. If the done function is called with a parameter, the inference \r\n * immediately stops (no more rules are executed from the agenda) and the \r\n * {@link inferenceCallback} is called with the same parameter (the error).\r\n *\r\n * @callback done\r\n * @param {Error|*} [err] - The error information to send to the \r\n *        {@link inferenceCallback}\r\n */\r\n\r\n\r\n/**\r\n * The rule callback is a function that takes a single {@link done} callback \r\n * method. This method is executed in the context of an {@link EngineProxy} \r\n * instance. It is important to note that before exiting a rule function, the\r\n * done callback function has to be called to inform the engine that the next\r\n * rule in the agenda has to be executed. Usually after calling the done \r\n * function the method should exits by explicitely calling 'return' or by \r\n * letting the execution exit the scope of the function.\r\n *\r\n * @callback rule\r\n * @this EngineProxy\r\n * @param {done} done - The done callback to call when the rule terminate\r\n *                      execution.\r\n */\r\n\r\n /**\r\n  * The trace callback is called when an event changing the engine state is \r\n  * hapenning. See {@link InfernalEngine#startTracing} for details.\r\n  *\r\n  * @callback traceCallback\r\n  * @param {object} trace - The trace data.\r\n  * @param {string} trace#action - Can be either 'reset', 'set', 'notify', \r\n  *                                'addRule', 'infer' or 'trace'.\r\n  * @param {string} [trace#rule] - The rule name that generated the trace. This\r\n  *                                property is undefined if the trace was not\r\n  *                                generated during inference.\r\n  * @param {string} [trace#fact] - The fact name if the trace action is 'set' \r\n  *                                or 'notify'.\r\n  * @param {*} [trace#oldValue]  - The previous value of the fact if the trace\r\n  *                                action is 'set'.\r\n  * @param {*} [trace#newValue]  - The new value of the fact if trace action \r\n  *                                is 'set' or 'notify'.\r\n  * @param {string} [trace#message] - The message sent by the \r\n  *                                {@ling EngineProxy#trace} method if trace\r\n  *                                action is 'trace'.\r\n  */\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/index.js\n ** module id = 0\n ** module chunks = 0 1\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 1\n ** module chunks = 0 1\n **/","/**\r\n * Module agenda\r\n */\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = Agenda;\r\n\r\n/**\r\n * Create an empty Agenda.\r\n * @class\r\n */\r\nfunction Agenda() {\r\n}\r\n\r\n\r\n/**\r\n * Removes the first element from the agenda and returns it.\r\n * \r\n * @returns {EngineProxy} - The next EngineProxy to be executed.\r\n */\r\nAgenda.prototype.shift = function() {\r\n    for (var key in this) {\r\n        if (key !== \"shift\" && key !== \"isEmpty\") {\r\n            var exec = this[key];\r\n            delete this[key];\r\n            return exec;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Tells if the agenda is empty.\r\n *\r\n * @returns {boolean} True if the agenda is empty, false otherwise.\r\n */\r\nAgenda.prototype.isEmpty = function() {\r\n    for (var key in this) {\r\n        if (key !== \"shift\" && key !== \"isEmpty\") {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/agenda.js\n ** module id = 2\n ** module chunks = 0 1\n **/","\"use strict\";\r\n\r\nexports.digPath     = digPath;\r\nexports.getContext  = getContext;\r\nexports.getFullName = getFullName;\r\nexports.deepCopy    = deepCopy;\r\nexports.equals      = equals;\r\n\r\n\r\n/*\r\n * Dig a path in a root object until it finds the property that contains the \r\n * leaf element of the path.\r\n *\r\n * @param root   The root object to dig into\r\n * @param path   The path formatted with forward slashes. Supports \"..\" to move \r\n *               up one object in the hierarchy.\r\n * @param create If set to true, create the object tree while digging instead \r\n *               of returning undefined when encountering an undefined path \r\n *               element.\r\n * \r\n * @return The last object in the path along with the target leaf name in an \r\n *         object having these two properties: 'target', 'name'. If create is\r\n *         falsy, returns undefined if the path element don't exists in the \r\n *         object hierarchy.\r\n */\r\nfunction digPath(facts, path, create) {\r\n    var hierarchy = path.split(/\\//g);\r\n    var heap = [facts];\r\n    var root = facts;\r\n    var factFullName = \"\";\r\n    while (hierarchy.length > 1) {\r\n        var name = hierarchy.shift();\r\n        if (name === \"..\") {\r\n            if (heap.length !== 0) {\r\n                heap.pop();\r\n                if (heap.length === 0) {\r\n                    root = facts;\r\n                } else {\r\n                    root = heap[heap.length - 1];\r\n                }\r\n            }\r\n        } else if (name !== \"\") {\r\n            factFullName += \"/\" + name;\r\n            if (!root[name]) {\r\n                if (!create) {\r\n                    return undefined;\r\n                } else {\r\n                    root[name] = {};\r\n                }\r\n            }\r\n            root = root[name]\r\n            heap.push(root);\r\n        }\r\n    }\r\n    return {\r\n        data: heap.pop(),\r\n        name: hierarchy[0],\r\n        fullName: factFullName + \"/\" + hierarchy[0]\r\n    };\r\n}\r\n\r\n\r\nfunction getContext(currentContext, path) {\r\n    var fullName = getFullName(currentContext, path);\r\n    var lastSlash = fullName.lastIndexOf(\"/\");\r\n    return fullName.substring(0, lastSlash + 1);\r\n}\r\n\r\nfunction getFullName(context, path) {\r\n    \r\n    if (!context || context.indexOf(\"/\") !== 0) {\r\n        throw new Error(\"context must start with a '/'. Value: '\" + \r\n            context + \"'\");\r\n    }\r\n    \r\n    if (path.indexOf(\"/\") === 0) {\r\n        // Since \"path\" starts with a '/' means that \"path\" is absolute. We \r\n        // don't care about the context in that case.\r\n        return getFullName(path, \"\");\r\n    }\r\n\r\n    var contextArray = context.split(\"/\");\r\n    var pathArray = path.split(\"/\");\r\n    var contextStack = contextArray.concat(pathArray);\r\n\r\n    // Here, \"contextStack\" should contains an array of all elements in the \r\n    // path. We expect \"contextStack[0]\" to contains an empty string. That\r\n    // empty string represents the root of the path and must be there.\r\n\r\n    var stack = [];\r\n    for (var i = 0; i < contextStack.length; i++) {\r\n        var contextPart = contextStack[i];\r\n        if (i === 0 || contextPart !== \"\") {    \r\n            // Keeps initial empty contextPart (root) and skip subsequent empty\r\n            // contextStack. This will make path like \"/a/b//c\" into \"/a/b/c\".\r\n            if (contextPart === \"..\") {\r\n                if (stack.length > 1) {\r\n                    stack.pop();\r\n                }\r\n            } else {\r\n                stack.push(contextPart);\r\n            }\r\n        }\r\n    }\r\n\r\n    var fullName = \"\";\r\n    for (var i = 0; i < stack.length; i++) {\r\n        if (i > 0) {\r\n            fullName += \"/\";\r\n        }\r\n        fullName += stack[i];\r\n    }\r\n\r\n    return fullName;\r\n}\r\n\r\n\r\nfunction deepCopy(target, source) {\r\n    var sourceType = typeof source;\r\n    if (sourceType !== \"object\") {\r\n        return deepCopy({}, target);\r\n    }\r\n    if (sourceType !== \"object\" || (source instanceof Date)) {\r\n        throw new Error(\"The 'source' parameter must be an object.\");\r\n    }\r\n    for (var property in source) {\r\n        var propertyType = typeof source[property];\r\n        if ((propertyType === \"object\") &&\r\n                (source[property] !== null) &&\r\n                !(source[property] instanceof Date) &&\r\n                !(source[property] instanceof Array)) {\r\n            target[property] = target[property] || {};\r\n            deepCopy(target[property], source[property]);\r\n        } else if (propertyType !== \"function\") {\r\n            target[property] = source[property];\r\n        }\r\n    }\r\n    return target;\r\n}\r\n\r\n\r\nfunction equals(a, b) {\r\n    var aValue = a;\r\n    if (a instanceof Date) {\r\n        aValue = a.getTime(); \r\n    }\r\n    var bValue = b;\r\n    if (b instanceof Date) {\r\n        bValue = b.getTime();\r\n    }\r\n    return (aValue === bValue) && ((typeof a) === (typeof b));\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/utils.js\n ** module id = 3\n ** module chunks = 0 1\n **/","\"use strict\";\r\n\r\nvar utils = require(\"./utils\");\r\n\r\n\r\nmodule.exports = EngineProxy;\r\n\r\n/**\r\n * Creates an engine proxy class to hold a rule context of execution.\r\n * @class\r\n * @param {InfernalEngine} engine - The engine being proxied.\r\n * @param {string} - the rule name that will execute under the EngineProxy \r\n *                   context.\r\n */\r\nfunction EngineProxy(engine, ruleName) {\r\n    this.engine = engine;\r\n    this.ruleName = ruleName;\r\n    this.context = utils.getContext(\"/\", ruleName);\r\n}\r\n\r\n\r\n/**\r\n * Gets the fact value for the given factName. Note that the factName can be \r\n * a relative path to the current rule context. Usage of \"..\" allows to go\r\n * up the context stack to reach parents and sibling facts.\r\n *\r\n * @param {string} factName - The fact name.\r\n * \r\n * @returns {*} The fact value.\r\n */\r\nEngineProxy.prototype.get = function(factName) {\r\n    var fullFactName = utils.getFullName(this.context, factName);\r\n    return this.engine.get(fullFactName);\r\n};\r\n\r\n\r\n/**\r\n * Sets a fact value for the given fact name. The fact name can be a relative \r\n * path. See {@link EngineProxy#get} for details.\r\n *\r\n * @oaram {string} factName - the fact name.\r\n * @param {*} value - The value to set to the fact.\r\n *\r\n * @returns {EngineProxy} A reference to \"this\" object for method chaining.\r\n */\r\nEngineProxy.prototype.set = function(factName, value) {\r\n    var fullFactName = utils.getFullName(this.context, factName);\r\n    var oldValue = this.engine.get(fullFactName);\r\n    this.engine.set(fullFactName, value);\r\n\r\n    if ((typeof this.engine._trace === \"function\") && !utils.equals(oldValue, value)) {\r\n        var self = this;\r\n        process.nextTick(function() {\r\n            self.engine._trace({\r\n                action: \"set\",\r\n                rule: self.ruleName,\r\n                fact: fullFactName,\r\n                oldValue: oldValue,\r\n                newValue: value\r\n            });\r\n        });\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Notifies that the given fact has changed. The fact name can be a relative \r\n * path. See {@link EngineProxy#get} for details.\r\n *\r\n * @param {string} factName - The fact name.\r\n *\r\n * @returns {EngineProxy} A reference to \"this\" object for method chaining.\r\n */\r\nEngineProxy.prototype.notify = function(factName) {\r\n    var fullFactName = utils.getFullName(this.context, factName);\r\n    this.engine.notify(fullFactName);\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * This method sends a trace message to the tracing function, if tracing \r\n * is activated.\r\n *\r\n * @param {string} message - The message to send to the trace function.\r\n *\r\n * @returns {EngineProxy} A reference to \"this\" object for method chaining.\r\n */\r\nEngineProxy.prototype.trace = function(message) {\r\n    if (typeof this.engine._trace === \"function\") {\r\n        var self = this;\r\n        process.nextTick(function() {\r\n            self.engine._trace({\r\n                action: \"trace\",\r\n                rule: self.ruleName,\r\n                message: message\r\n            });\r\n        });\r\n    }\r\n    return this;\r\n}\r\n\r\n\r\n// private\r\nEngineProxy.prototype._executeRule = function(callback) {\r\n   this.engine._rules[this.ruleName].call(this, callback);\r\n   return this;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/engine-proxy.js\n ** module id = 4\n ** module chunks = 0 1\n **/"],"sourceRoot":""}