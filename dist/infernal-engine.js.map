{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap b4012e7b42b1be86f0d1","webpack:///./lib/index.js","webpack:///./~/process/browser.js","webpack:///./lib/agenda.js","webpack:///./lib/utils.js","webpack:///./lib/engine-proxy.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,eAAc,OAAO;AACrB;AACA;AACA;AACA,0BAAyB;AACzB,0BAAyB;AACzB,0BAAyB;AACzB,4BAA2B;AAC3B,4BAA2B;AAC3B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,gBAAgB;AACzC,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,EAAE;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,EAAE;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,cAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,YAAW,KAAK;AAChB;AACA;AACA;AACA;AACA,cAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAqB,kCAAkC;AACvD;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,cAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,cAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,kBAAkB;AAC7B;AACA,cAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,8BAA6B,gBAAgB;AAC7C,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;;;AAGA;AACA;AACA,YAAW,cAAc;AACzB;AACA,YAAW,4BAA4B;AACvC,YAAW,0BAA0B;AACrC,YAAW,6BAA6B;AACxC,YAAW,8BAA8B;AACzC,YAAW,4BAA4B;AACvC,YAAW,wBAAwB;AACnC;AACA,cAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA,MAAK;AACL;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAW,QAAQ;AACnB;;;AAGA;AACA;AACA;AACA,qBAAoB,wBAAwB;AAC5C;AACA;AACA,KAAI,wBAAwB;AAC5B;AACA;AACA,YAAW,QAAQ;AACnB,YAAW;AACX;;;AAGA;AACA,yDAAwD,WAAW;AACnE,0DAAyD,kB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB;AACA;;AAEA;AACA;AACA,qBAAoB,kCAAkC;AACtD;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB;AACA,aAAY,OAAO;AACnB;AACA;AACA,aAAY,OAAO;AACnB;AACA,aAAY,EAAE;AACd;AACA,aAAY,EAAE;AACd;AACA,aAAY,OAAO;AACnB,qCAAoC,wBAAwB;AAC5D;AACA;;;;;;;;AC1cA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA2B;AAC3B;AACA;AACA;AACA,6BAA4B,UAAU;;;;;;;AC1FtC;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,cAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3CA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAmB,yBAAyB;AAC5C;AACA,6C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,8B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvJA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA,YAAW,eAAe;AAC1B,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,cAAa,EAAE;AACf;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,eAAc,sBAAsB;AACpC;AACA,YAAW,OAAO;AAClB,YAAW,EAAE;AACb;AACA,cAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA,eAAc,sBAAsB;AACpC;AACA,YAAW,OAAO;AAClB;AACA,cAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,cAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA","file":"infernal-engine.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"InfernalEngine\"] = factory();\n\telse\n\t\troot[\"InfernalEngine\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap b4012e7b42b1be86f0d1\n **/","/**\n * Main module of the library, defines the class InfernalEngine and its\n * private methods.\n * Module infernal-engine\n */\n\n\"use strict\";\n\nvar Agenda      = require(\"./agenda\");\nvar utils       = require(\"./utils\");\nvar EngineProxy = require(\"./engine-proxy\");\n\nmodule.exports = InfernalEngine;\n\n\n/**\n * InfernalEngine class constructor.\n * @class\n *\n * @param {number} [timeout=5000] - How long the inference can take before\n *        the inference callback is called with a timeout error.\n *\n * @property {number} timeout - The timeout value in milliseconds set by the \n *                              constructor.\n */\nfunction InfernalEngine(timeout) {\n    this._facts     = {}; // Graph of facts\n    this._rules     = {}; // Map between rule names and rules (function)\n    this._relations = {}; // Map between fact names and all related rules\n    this._diffFacts = null; // A map of fact names that changed\n    this._trace     = null; // the tracing function\n    this._agenda    = new Agenda();\n    this._infering  = false;\n\n    this.timeout    = 5000;\n\n    if (timeout) {\n        this.timeout = timeout;\n    }\n}\n\n/**\n * Resets the engine to its inintial state. Do not change timeout value \n * nor the tracer function.\n */\nInfernalEngine.prototype.reset = function() {\n    this._facts     = {};\n    this._rules     = {};\n    this._relations = {};\n    this._diffFacts = null;\n    this._agenda    = new Agenda();\n    this._infering  = false;\n    if (typeof this._trace === \"function\") {\n        process.nextTick((function() {\n            this._trace({action: \"reset\"});\n        }).bind(this));\n    }\n};\n\n/**\n * Gets a value of the given factName. A factName is made of a context and \n * the fact simple name separated by '/'. Accessing a fact from the engine\n * assumes the context to be \"/\". Within a rule, the context\n * would be the same as the rule context.\n * \n * @param {string} factName - The fact name.\n * @returns {*} the fact value.\n */\nInfernalEngine.prototype.get = function(factName) {\n    if (factName.charAt(0) !== \"/\") {\n        return this.get(\"/\" + factName);\n    }\n\n    var fact = utils.digPath.call(this, this._facts, factName);\n    if (fact === undefined) {\n        return undefined;\n    }\n\n    return fact.data[fact.name];\n};\n\n\n/**\n * Sets a fact value for the given factName.\n *\n * @param {string} factName - The fact name.\n * @param {*} value - The fact value to be set.\n */\nInfernalEngine.prototype.set = function(factName, value) {\n   \n    if (factName.charAt(0) !== \"/\") {\n        return this.set(\"/\" + factName, value);\n    }\n\n    var oldValue = this.get(factName);\n    if (!utils.equals(oldValue, value)) {\n        var fact = utils.digPath.call(this, this._facts, factName, true);\n        \n        if (this._diffFacts) {\n            this._diffFacts[fact.fullName] = true;\n        }\n        \n        var oldValue = fact.data[fact.name];\n        fact.data[fact.name] = value;\n        \n        updateAgenda.call(this, factName);\n\n        if ((typeof this._trace === \"function\") && !this._infering) {\n            process.nextTick((function() {\n                this._trace({\n                    action: \"set\",\n                    fact: factName,\n                    oldValue: oldValue,\n                    newValue: value\n                });\n            }).bind(this));\n        }\n    }\n\n    return this;\n};\n\n\n/**\n * Notifies the engine to consider the given factName was updated. This method\n * is usefull when changing the content of an array without changing the array\n * reference.\n *\n * @param {string} factName - The fact name that have to be considered \n *                            changed by the engine.\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\n */\nInfernalEngine.prototype.notify = function(factName) {\n    if (factName.charAt(0) !== \"/\") {\n        return this.notify(\"/\" + factName, value);\n    }\n    updateAgenda.call(this, factName);\n    if ((typeof this._trace === \"function\") && !this._infering) {\n        process.nextTick((function() {\n            this._trace({\n                action: \"notify\",\n                fact: factName,\n                newValue: value\n            });\n        }).bind(this));\n    }\n    return this;\n};\n\n\n/**\n * Adds a rule to the engine.\n * \n * @param {string} ruleName\n *        The rule name, each segment separated by a '/'. A rule name cannot\n *        ends with '/'.\n *\n * @param {rule} rule \n *        The rule function has only one paramter: the 'done' function. When\n *        the rule evaluation is terminated, the done function must be called\n *        to tell the engine to execute the next rule in the agenda.\n *\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\n */\nInfernalEngine.prototype.addRule = function(ruleName, rule) {\n    if (typeof ruleName === \"function\") {\n        rule = ruleName;\n        ruleName = \"/\" + rule.name;\n    }\n    \n    if (ruleName.indexOf(\"/\") !== 0) {\n        ruleName = \"/\" + ruleName;\n    }\n    \n    var ruleContent = rule.toString();\n    var regex = /this\\.get\\([\"']?(.*?)[\"']?\\)/gm;\n    var match = regex.exec(ruleContent);\n    var factName;\n    this._rules[ruleName] = rule;\n\n    while (match) {\n        var context = utils.getContext(\"/\", ruleName);\n        factName = utils.getFullName(context, match[1]);\n        if (this._relations[factName] === undefined) {\n            this._relations[factName] = {};\n        }\n        this._relations[factName][ruleName] = true;\n        match = regex.exec(ruleContent);\n    }\n\n    if (typeof this._trace === \"function\") {\n        this._trace({action: \"addRule\", rule: ruleName});\n    }\n\n    return this;\n};\n\n\n/**\n * Gets the subset of facts that changed during the last call to infer().\n *\n * @returns {object} an object containing all facts that changed during the \n *                   last inference.\n */\nInfernalEngine.prototype.getDiff = function() {\n    var diff = {};\n    for (var factName in this._diffFacts) {\n        var fact = utils.digPath(diff, factName, true);\n        fact.data[fact.name] = this.get(factName);\n    }\n    return diff;\n};\n\n\n/**\n * Gets a deep copy of the internal facts object. When a fact contains an \n * array, that array reference is kept in the returned object. Modifying \n * that array would result in modifying the original array from the internal\n * facts.\n * \n * @returns {object} a deep copy of the internal facts.\n */\nInfernalEngine.prototype.getFacts = function() {\n    return utils.deepCopy(this._facts);\n};\n\n/**\n * Sets the internal facts to the values received in the facts parameter. The \n * internal facts reference is not changed to the object received. Instead,\n * the object tree is is read and each fact it contains are \"set\" so that any\n * changes to the actual internal fact values will trigger rules as required. \n * Functions are ingnored by that operation.\n *\n * @param {object} An object tree used to update internal facts.\n *\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\n */\nInfernalEngine.prototype.setFacts = function(facts) {\n    applyFacts.call(this, \"\", facts)\n    return this;\n};\n\n/**\n * Loads a model into the engine. This operation resets the engine and loads\n * that model's properties as facts and methods as rules.\n *\n * @param {object} model - A model object containing facts and rules.\n *\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\n */\nInfernalEngine.prototype.load = function(model) {\n    this.reset();\n    applyFacts.call(this, \"\", model, true);\n    return this;\n};\n\n\n/**\n * Starts the inference. The inference executes all rules in the agenda. Once\n * the inference is done, either because the agenda is empty or becaus the \n * inference timeout is reached, the callback method is called.\n *\n * @param {number} [timeout=InfernalEngine#timeout] The timeout period in \n *        milliseconds given to the infer call.\n *\n * @param {inferenceCallback} callback - The function to be executed when done.\n *\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\n */\nInfernalEngine.prototype.infer = function(timeout, callback) {\n    if (typeof timeout === \"function\") {\n        var actualCallback = timeout;\n        this.infer(this.timeout, actualCallback);\n        return;\n    }\n\n    if (this._agenda.isEmpty()) {\n        this._infering = false;\n        clearTimeout(this.timeoutId);\n        callback();\n        return;\n    }\n\n    if (timeout > 0 ) {\n        this._infering = true;\n        this._diffFacts = {};\n        this.timeoutId = setTimeout((function() {\n            this._infering = false;\n            callback(new Error( \n                \"Inference timed out after \" + timeout + \" ms\"));\n            return;\n        }).bind(this), timeout);\n        if (typeof this._trace === \"function\") {\n            process.nextTick((function() {\n                this._trace({action: \"infer\"});\n            }).bind(this));\n        }\n    }\n\n    if (this._infering === false) {\n        callback(new Error(\"The timeout parameter must be grater than zero \" +\n            \"to start infering.\"));\n        return;\n    }\n\n    var proxy = this._agenda.shift();\n    \n    process.nextTick((function() {\n        proxy._executeRule((function(err) {\n            if(err) {\n                this._infering = false;\n                clearTimeout(this.timeoutId);\n                callback(err);\n                return;\n            }\n            if (this._infering) {\n                this.infer(0, callback);\n            }\n        }).bind(this));\n    }).bind(this));\n\n    return this;\n};\n\n\n/**\n * Starts tracing the engine's operations.\n * @param {traceCallback} traceFunction The function called when an event\n *        is taking place. Events that generate a traceFunction call are:\n *        {@link InferenceEngine#reset}, \n *        {@link InferenceEngine#set},\n *        {@link InferenceEngine#notify},\n *        {@link InferenceEngine#addRule},\n *        {@link InferenceEngine#infer} and\n *        {@link EngineProxy#trace}.\n *\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\n */\nInfernalEngine.prototype.startTracing = function(traceFunction) {\n    if (!traceFunction) {\n        throw new Error(\"The parameter 'traceFunction' is mandatory.\");\n    }\n    this._trace = traceFunction;\n    return this;\n};\n\n/**\n * Stops calling any trace callback that could have been defined. Has no \n * effect if startStracing wasn't called before.\n *\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\n */\nInfernalEngine.prototype.stopTracing = function() {\n    this._trace = null;\n    return this;\n};\n\n\n\n// Private\n\nfunction applyFacts(context, source, loading) {\n    var sourceType = typeof source;\n    if ((sourceType === \"object\") && (source instanceof Date)) {\n        sourceType = \"date\";\n    }\n    \n    if ((sourceType === \"object\") && (source instanceof Array)) {\n        sourceType = \"array\";\n    }\n    \n    if (sourceType === \"function\") {\n        if (!loading) {\n            return;\n        } else {\n            this.addRule(context, source);\n        }\n\n    } else if (sourceType === \"object\") {\n        for (var property in source) {\n            applyFacts.call(this, context + \"/\" + property, source[property], loading);\n        }\n\n    } else {\n        this.set(context, source);\n    }\n}\n\n\nfunction updateAgenda(factName) {\n    if (this._relations[factName] !== undefined) {\n        var rules = this._relations[factName];\n        for (var ruleName in rules) {\n            if (rules.hasOwnProperty(ruleName) && \n                    (typeof this._agenda[ruleName] === \"undefined\")) {\n                this._agenda[ruleName] = new EngineProxy(this, ruleName);\n            }\n        }\n    }\n}\n\n\n/**\n * The inference callback function.\n * @callback inferenceCallback\n * @param {Error|*} [err] - The error information if something wrong happened.\n */\n\n\n/**\n * The done function tells the inference engine that the current rule is \n * terminated and that the next rule shall be executed. If no more rule are in\n * the agenda, the {@link inferenceCallback} function is called without any \n * parameter. If the done function is called with a parameter, the inference \n * immediately stops (no more rules are executed from the agenda) and the \n * {@link inferenceCallback} is called with the same parameter (the error).\n *\n * @callback done\n * @param {Error|*} [err] - The error information to send to the \n *        {@link inferenceCallback}\n */\n\n\n/**\n * The rule callback is a function that takes a single {@link done} callback \n * method. This method is executed in the context of an {@link EngineProxy} \n * instance. It is important to note that before exiting a rule function, the\n * done callback function has to be called to inform the engine that the next\n * rule in the agenda has to be executed. Usually after calling the done \n * function the method should exits by explicitely calling 'return' or by \n * letting the execution exit the scope of the function.\n *\n * @callback rule\n * @this EngineProxy\n * @param {done} done - The done callback to call when the rule terminate\n *                      execution.\n */\n\n /**\n  * The trace callback is called when an event changing the engine state is \n  * hapenning. See {@link InfernalEngine#startTracing} for details.\n  *\n  * @callback traceCallback\n  * @param {object} trace - The trace data.\n  * @param {string} trace#action - Can be either 'reset', 'set', 'notify', \n  *                                'addRule', 'infer' or 'trace'.\n  * @param {string} [trace#rule] - The rule name that generated the trace. This\n  *                                property is undefined if the trace was not\n  *                                generated during inference.\n  * @param {string} [trace#fact] - The fact name if the trace action is 'set' \n  *                                or 'notify'.\n  * @param {*} [trace#oldValue]  - The previous value of the fact if the trace\n  *                                action is 'set'.\n  * @param {*} [trace#newValue]  - The new value of the fact if trace action \n  *                                is 'set' or 'notify'.\n  * @param {string} [trace#message] - The message sent by the \n  *                                {@ling EngineProxy#trace} method if trace\n  *                                action is 'trace'.\n  */\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/index.js\n ** module id = 0\n ** module chunks = 0 1\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/process/browser.js\n ** module id = 1\n ** module chunks = 0 1\n **/","/**\n * Module agenda\n */\n\n\"use strict\";\n\nmodule.exports = Agenda;\n\n/**\n * Create an empty Agenda.\n * @class\n */\nfunction Agenda() {\n}\n\n\n/**\n * Removes the first element from the agenda and returns it.\n * \n * @returns {EngineProxy} - The next EngineProxy to be executed.\n */\nAgenda.prototype.shift = function() {\n    for (var key in this) {\n        if (key !== \"shift\" && key !== \"isEmpty\") {\n            var exec = this[key];\n            delete this[key];\n            return exec;\n        }\n    }\n}\n\n/**\n * Tells if the agenda is empty.\n *\n * @returns {boolean} True if the agenda is empty, false otherwise.\n */\nAgenda.prototype.isEmpty = function() {\n    for (var key in this) {\n        if (key !== \"shift\" && key !== \"isEmpty\") {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/agenda.js\n ** module id = 2\n ** module chunks = 0 1\n **/","\"use strict\";\n\nexports.digPath     = digPath;\nexports.getContext  = getContext;\nexports.getFullName = getFullName;\nexports.deepCopy    = deepCopy;\nexports.equals      = equals;\n\n\n/*\n * Dig a path in a root object until it finds the property that contains the \n * leaf element of the path.\n *\n * @param root   The root object to dig into\n * @param path   The path formatted with forward slashes. Supports \"..\" to move \n *               up one object in the hierarchy.\n * @param create If set to true, create the object tree while digging instead \n *               of returning undefined when encountering an undefined path \n *               element.\n * \n * @return The last object in the path along with the target leaf name in an \n *         object having these two properties: 'target', 'name'. If create is\n *         falsy, returns undefined if the path element don't exists in the \n *         object hierarchy.\n */\nfunction digPath(facts, path, create) {\n    var hierarchy = path.split(/\\//g);\n    var heap = [facts];\n    var root = facts;\n    var factFullName = \"\";\n    while (hierarchy.length > 1) {\n        var name = hierarchy.shift();\n        if (name === \"..\") {\n            if (heap.length !== 0) {\n                heap.pop();\n                if (heap.length === 0) {\n                    root = facts;\n                } else {\n                    root = heap[heap.length - 1];\n                }\n            }\n        } else if (name !== \"\") {\n            factFullName += \"/\" + name;\n            if (!root[name]) {\n                if (!create) {\n                    return undefined;\n                } else {\n                    root[name] = {};\n                }\n            }\n            root = root[name]\n            heap.push(root);\n        }\n    }\n    return {\n        data: heap.pop(),\n        name: hierarchy[0],\n        fullName: factFullName + \"/\" + hierarchy[0]\n    };\n}\n\n\nfunction getContext(currentContext, path) {\n    var fullName = getFullName(currentContext, path);\n    var lastSlash = fullName.lastIndexOf(\"/\");\n    return fullName.substring(0, lastSlash + 1);\n}\n\nfunction getFullName(context, path) {\n    \n    if (!context || context.indexOf(\"/\") !== 0) {\n        throw new Error(\"context must start with a '/'. Value: '\" + \n            context + \"'\");\n    }\n    \n    if (path.indexOf(\"/\") === 0) {\n        // Since \"path\" starts with a '/' means that \"path\" is absolute. We \n        // don't care about the context in that case.\n        return getFullName(path, \"\");\n    }\n\n    var contextArray = context.split(\"/\");\n    var pathArray = path.split(\"/\");\n    var contextStack = contextArray.concat(pathArray);\n\n    // Here, \"contextStack\" should contains an array of all elements in the \n    // path. We expect \"contextStack[0]\" to contains an empty string. That\n    // empty string represents the root of the path and must be there.\n\n    var stack = [];\n    for (var i = 0; i < contextStack.length; i++) {\n        var contextPart = contextStack[i];\n        if (i === 0 || contextPart !== \"\") {    \n            // Keeps initial empty contextPart (root) and skip subsequent empty\n            // contextStack. This will make path like \"/a/b//c\" into \"/a/b/c\".\n            if (contextPart === \"..\") {\n                if (stack.length > 1) {\n                    stack.pop();\n                }\n            } else {\n                stack.push(contextPart);\n            }\n        }\n    }\n\n    var fullName = \"\";\n    for (var i = 0; i < stack.length; i++) {\n        if (i > 0) {\n            fullName += \"/\";\n        }\n        fullName += stack[i];\n    }\n\n    return fullName;\n}\n\n\nfunction deepCopy(target, source) {\n    var sourceType = typeof source;\n    if (sourceType !== \"object\") {\n        return deepCopy({}, target);\n    }\n    if (sourceType !== \"object\" || (source instanceof Date)) {\n        throw new Error(\"The 'source' parameter must be an object.\");\n    }\n    for (var property in source) {\n        var propertyType = typeof source[property];\n        if ((propertyType === \"object\") &&\n                (source[property] !== null) &&\n                !(source[property] instanceof Date) &&\n                !(source[property] instanceof Array)) {\n            target[property] = target[property] || {};\n            deepCopy(target[property], source[property]);\n        } else if (propertyType !== \"function\") {\n            target[property] = source[property];\n        }\n    }\n    return target;\n}\n\n\nfunction equals(a, b) {\n    var aValue = a;\n    if (a instanceof Date) {\n        aValue = a.getTime(); \n    }\n    var bValue = b;\n    if (b instanceof Date) {\n        bValue = b.getTime();\n    }\n    return (aValue === bValue) && ((typeof a) === (typeof b));\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/utils.js\n ** module id = 3\n ** module chunks = 0 1\n **/","\"use strict\";\n\nvar utils = require(\"./utils\");\n\n\nmodule.exports = EngineProxy;\n\n/**\n * Creates an engine proxy class to hold a rule context of execution.\n * @class\n * @param {InfernalEngine} engine - The engine being proxied.\n * @param {string} - the rule name that will execute under the EngineProxy \n *                   context.\n */\nfunction EngineProxy(engine, ruleName) {\n    this.engine = engine;\n    this.ruleName = ruleName;\n    this.context = utils.getContext(\"/\", ruleName);\n}\n\n\n/**\n * Gets the fact value for the given factName. Note that the factName can be \n * a relative path to the current rule context. Usage of \"..\" allows to go\n * up the context stack to reach parents and sibling facts.\n *\n * @param {string} factName - The fact name.\n * \n * @returns {*} The fact value.\n */\nEngineProxy.prototype.get = function(factName) {\n    var fullFactName = utils.getFullName(this.context, factName);\n    return this.engine.get(fullFactName);\n};\n\n\n/**\n * Sets a fact value for the given fact name. The fact name can be a relative \n * path. See {@link EngineProxy#get} for details.\n *\n * @oaram {string} factName - the fact name.\n * @param {*} value - The value to set to the fact.\n *\n * @returns {EngineProxy} A reference to \"this\" object for method chaining.\n */\nEngineProxy.prototype.set = function(factName, value) {\n    var fullFactName = utils.getFullName(this.context, factName);\n    var oldValue = this.engine.get(fullFactName);\n    this.engine.set(fullFactName, value);\n\n    if ((typeof this.engine._trace === \"function\") && !utils.equals(oldValue, value)) {\n        var self = this;\n        process.nextTick(function() {\n            self.engine._trace({\n                action: \"set\",\n                rule: self.ruleName,\n                fact: fullFactName,\n                oldValue: oldValue,\n                newValue: value\n            });\n        });\n    }\n\n    return this;\n};\n\n/**\n * Notifies that the given fact has changed. The fact name can be a relative \n * path. See {@link EngineProxy#get} for details.\n *\n * @param {string} factName - The fact name.\n *\n * @returns {EngineProxy} A reference to \"this\" object for method chaining.\n */\nEngineProxy.prototype.notify = function(factName) {\n    var fullFactName = utils.getFullName(this.context, factName);\n    this.engine.notify(fullFactName);\n    return this;\n};\n\n\n/**\n * This method sends a trace message to the tracing function, if tracing \n * is activated.\n *\n * @param {string} message - The message to send to the trace function.\n *\n * @returns {EngineProxy} A reference to \"this\" object for method chaining.\n */\nEngineProxy.prototype.trace = function(message) {\n    if (typeof this.engine._trace === \"function\") {\n        var self = this;\n        process.nextTick(function() {\n            self.engine._trace({\n                action: \"trace\",\n                rule: self.ruleName,\n                message: message\n            });\n        });\n    }\n    return this;\n}\n\n\n// private\nEngineProxy.prototype._executeRule = function(callback) {\n   this.engine._rules[this.ruleName].call(this, callback);\n   return this;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/engine-proxy.js\n ** module id = 4\n ** module chunks = 0 1\n **/"],"sourceRoot":""}