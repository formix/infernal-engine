{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap f39b6dc4dc5e7da853ae","webpack:///./lib/index.js","webpack:///(webpack)/~/node-libs-browser/~/process/browser.js","webpack:///./lib/agenda.js","webpack:///./lib/utils.js","webpack:///./lib/engine-proxy.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,eAAc,OAAO;AACrB;AACA;AACA;AACA,0BAAyB;AACzB,0BAAyB;AACzB,0BAAyB;AACzB,4BAA2B;AAC3B,4BAA2B;AAC3B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,gBAAgB;AACzC,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,EAAE;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,EAAE;AACb,YAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,cAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,YAAW,KAAK;AAChB;AACA;AACA;AACA;AACA,cAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAqB,kCAAkC;AACvD;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,cAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,cAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,kBAAkB;AAC7B;AACA,cAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,8BAA6B,gBAAgB;AAC7C,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;;;AAGA;AACA;AACA,YAAW,cAAc;AACzB;AACA,YAAW,4BAA4B;AACvC,YAAW,0BAA0B;AACrC,YAAW,6BAA6B;AACxC,YAAW,8BAA8B;AACzC,YAAW,4BAA4B;AACvC,YAAW,wBAAwB;AACnC;AACA,cAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA,MAAK;AACL;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAW,QAAQ;AACnB;;;AAGA;AACA;AACA;AACA,qBAAoB,wBAAwB;AAC5C;AACA;AACA,KAAI,wBAAwB;AAC5B;AACA;AACA,YAAW,QAAQ;AACnB,YAAW;AACX;;;AAGA;AACA,yDAAwD,WAAW;AACnE,0DAAyD,kB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB;AACA;;AAEA;AACA;AACA,qBAAoB,kCAAkC;AACtD;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB;AACA,aAAY,OAAO;AACnB;AACA;AACA,aAAY,OAAO;AACnB;AACA,aAAY,EAAE;AACd;AACA,aAAY,EAAE;AACd;AACA,aAAY,OAAO;AACnB,qCAAoC,wBAAwB;AAC5D;AACA;;;;;;;;ACjeA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA2B;AAC3B;AACA;AACA;AACA,6BAA4B,UAAU;;;;;;;AC1FtC;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,cAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3CA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAmB,yBAAyB;AAC5C;AACA,6C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,8B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvJA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA,YAAW,eAAe;AAC1B,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,cAAa,EAAE;AACf;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,eAAc,sBAAsB;AACpC;AACA,YAAW,OAAO;AAClB,YAAW,EAAE;AACb;AACA,cAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA,eAAc,sBAAsB;AACpC;AACA,YAAW,OAAO;AAClB;AACA,cAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,cAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA","file":"infernal-engine.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"InfernalEngine\"] = factory();\n\telse\n\t\troot[\"InfernalEngine\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap f39b6dc4dc5e7da853ae\n **/","/**\r\n * Main module of the library, defines the class InfernalEngine and its\r\n * private methods.\r\n * Module infernal-engine\r\n */\r\n\r\n\"use strict\";\r\n\r\nvar Agenda      = require(\"./agenda\");\r\nvar utils       = require(\"./utils\");\r\nvar EngineProxy = require(\"./engine-proxy\");\r\n\r\nmodule.exports = InfernalEngine;\r\n\r\n\r\n/**\r\n * InfernalEngine class constructor.\r\n * @class\r\n *\r\n * @param {number} [timeout=5000] - How long the inference can take before\r\n *        the inference callback is called with a timeout error.\r\n *\r\n * @property {number} timeout - The timeout value in milliseconds set by the \r\n *                              constructor.\r\n */\r\nfunction InfernalEngine(timeout) {\r\n    this._facts     = {}; // Graph of facts\r\n    this._rules     = {}; // Map between rule names and rules (function)\r\n    this._relations = {}; // Map between fact names and all related rules\r\n    this._changes   = null; // A map of fact names that changed\r\n    this._trace     = null; // the tracing function\r\n    this._agenda    = new Agenda();\r\n    this._infering  = false;\r\n\r\n    this.timeout    = 5000;\r\n\r\n    if (timeout) {\r\n        this.timeout = timeout;\r\n    }\r\n}\r\n\r\n/**\r\n * Resets the engine to its inintial state. Do not change timeout value \r\n * nor the tracer function.\r\n */\r\nInfernalEngine.prototype.reset = function() {\r\n    this._facts     = {};\r\n    this._rules     = {};\r\n    this._relations = {};\r\n    this._changes   = null;\r\n    this._agenda    = new Agenda();\r\n    this._infering  = false;\r\n    if (typeof this._trace === \"function\") {\r\n        process.nextTick((function() {\r\n            this._trace({action: \"reset\"});\r\n        }).bind(this));\r\n    }\r\n};\r\n\r\n/**\r\n * Gets a value of the given factName. A factName is made of a context and \r\n * the fact simple name separated by '/'. Accessing a fact from the engine\r\n * assumes the context to be \"/\". Within a rule, the context\r\n * would be the same as the rule context.\r\n * \r\n * @param {string} factName - The fact name.\r\n * @returns {*} the fact value.\r\n */\r\nInfernalEngine.prototype.get = function(factName) {\r\n    if (factName.charAt(0) !== \"/\") {\r\n        return this.get(\"/\" + factName);\r\n    }\r\n\r\n    var fact = utils.digPath.call(this, this._facts, factName);\r\n    if (fact === undefined) {\r\n        return undefined;\r\n    }\r\n\r\n    return fact.data[fact.name];\r\n};\r\n\r\n\r\n/**\r\n * Sets a fact value for the given factName.\r\n *\r\n * @param {string} factName - The fact name.\r\n * @param {*} value - The fact value to be set.\r\n * @param {function} [callback] - \r\n *        The callback(err, changes). Tha changes object is a mapping between\r\n *        every fact names and their final value.\r\n */\r\nInfernalEngine.prototype.set = function(factName, value, callback) {\r\n   \r\n    if (factName.charAt(0) !== \"/\") {\r\n        return this.set(\"/\" + factName, value, callback);\r\n    }\r\n\r\n    var oldValue = this.get(factName);\r\n    if (!utils.equals(oldValue, value)) {\r\n        var fact = utils.digPath.call(this, this._facts, factName, true);\r\n        \r\n        if (this._changes) {\r\n            this._changes[fact.fullName] = value;\r\n        }\r\n\r\n        var oldValue = fact.data[fact.name];\r\n        fact.data[fact.name] = value;\r\n        \r\n        updateAgenda.call(this, factName);\r\n\r\n        if ((typeof this._trace === \"function\") && !this._infering) {\r\n            process.nextTick((function() {\r\n                this._trace({\r\n                    action: \"set\",\r\n                    fact: factName,\r\n                    oldValue: oldValue,\r\n                    newValue: value\r\n                });\r\n            }).bind(this));\r\n        }\r\n\r\n        if (callback) {\r\n            this.infer((function(err) {\r\n                if (err) {\r\n                    callback(err);\r\n                    return;\r\n                }\r\n                callback(null, this.getChanges());\r\n            }).bind(this));\r\n        }\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * Notifies the engine to consider the given factName was updated. This method\r\n * is usefull when changing the content of an array without changing the array\r\n * reference.\r\n *\r\n * @param {string} factName - The fact name that have to be considered \r\n *                            changed by the engine.\r\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\r\n */\r\nInfernalEngine.prototype.notify = function(factName) {\r\n    if (factName.charAt(0) !== \"/\") {\r\n        return this.notify(\"/\" + factName, value);\r\n    }\r\n    updateAgenda.call(this, factName);\r\n    if ((typeof this._trace === \"function\") && !this._infering) {\r\n        process.nextTick((function() {\r\n            this._trace({\r\n                action: \"notify\",\r\n                fact: factName,\r\n                newValue: value\r\n            });\r\n        }).bind(this));\r\n    }\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * Adds a rule to the engine.\r\n * \r\n * @param {string} ruleName\r\n *        The rule name, each segment separated by a '/'. A rule name cannot\r\n *        ends with '/'.\r\n *\r\n * @param {rule} rule \r\n *        The rule function has only one paramter: the 'done' function. When\r\n *        the rule evaluation is terminated, the done function must be called\r\n *        to tell the engine to execute the next rule in the agenda.\r\n *\r\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\r\n */\r\nInfernalEngine.prototype.addRule = function(ruleName, rule) {\r\n    if (typeof ruleName === \"function\") {\r\n        rule = ruleName;\r\n        ruleName = \"/\" + rule.name;\r\n    }\r\n    \r\n    if (ruleName.indexOf(\"/\") !== 0) {\r\n        ruleName = \"/\" + ruleName;\r\n    }\r\n    \r\n    var ruleContent = rule.toString();\r\n    var regex = /this\\.get\\([\"']?(.*?)[\"']?\\)/gm;\r\n    var match = regex.exec(ruleContent);\r\n    var factName;\r\n    this._rules[ruleName] = rule;\r\n\r\n    while (match) {\r\n        var context = utils.getContext(\"/\", ruleName);\r\n        factName = utils.getFullName(context, match[1]);\r\n        if (this._relations[factName] === undefined) {\r\n            this._relations[factName] = {};\r\n        }\r\n        this._relations[factName][ruleName] = true;\r\n        match = regex.exec(ruleContent);\r\n    }\r\n\r\n    if (typeof this._trace === \"function\") {\r\n        this._trace({action: \"addRule\", rule: ruleName});\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * Gets the subset of facts that changed during the last call to infer().\r\n *\r\n * @returns {object} an object containing all facts that changed during the \r\n *                   last inference.\r\n */\r\nInfernalEngine.prototype.getDiff = function() {\r\n    var diff = {};\r\n    for (var factName in this._changes) {\r\n        var fact = utils.digPath(diff, factName, true);\r\n        fact.data[fact.name] = this.get(factName);\r\n    }\r\n    return diff;\r\n};\r\n\r\n\r\n/**\r\n * Gets an object mapping the fact full name to the last change the given\r\n * fact got through.\r\n *\r\n * @returns {object} A map of fact paths and their corresponding values.\r\n */\r\nInfernalEngine.prototype.getChanges = function() {\r\n    return utils.deepCopy(this._changes);\r\n};\r\n\r\n/**\r\n * Gets a deep copy of the internal facts object. When a fact contains an \r\n * array, that array reference is kept in the returned object. Modifying \r\n * that array would result in modifying the original array from the internal\r\n * facts.\r\n * \r\n * @returns {object} a deep copy of the internal facts.\r\n */\r\nInfernalEngine.prototype.getFacts = function() {\r\n    return utils.deepCopy(this._facts);\r\n};\r\n\r\n/**\r\n * Sets the internal facts to the values received in the facts parameter. The \r\n * internal facts reference is not changed to the object received. Instead,\r\n * the object tree is is read and each fact it contains are \"set\" so that any\r\n * changes to the actual internal fact values will trigger rules as required. \r\n * Functions are ingnored by that operation.\r\n *\r\n * @param {object} An object tree used to update internal facts.\r\n *\r\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\r\n */\r\nInfernalEngine.prototype.setFacts = function(facts) {\r\n    applyFacts.call(this, \"\", facts)\r\n    return this;\r\n};\r\n\r\n/**\r\n * Loads a model into the engine. This operation resets the engine and loads\r\n * that model's properties as facts and methods as rules.\r\n *\r\n * @param {object} model - A model object containing facts and rules.\r\n *\r\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\r\n */\r\nInfernalEngine.prototype.load = function(model) {\r\n    this.reset();\r\n    applyFacts.call(this, \"\", model, true);\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * Starts the inference. The inference executes all rules in the agenda. Once\r\n * the inference is done, either because the agenda is empty or becaus the \r\n * inference timeout is reached, the callback method is called.\r\n *\r\n * @param {number} [timeout=InfernalEngine#timeout] The timeout period in \r\n *        milliseconds given to the infer call.\r\n *\r\n * @param {inferenceCallback} callback - The function to be executed when done.\r\n *\r\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\r\n */\r\nInfernalEngine.prototype.infer = function(timeout, callback) {\r\n    if (typeof timeout === \"function\") {\r\n        var actualCallback = timeout;\r\n        this.infer(this.timeout, actualCallback);\r\n        return;\r\n    }\r\n\r\n    if (this._agenda.isEmpty()) {\r\n        this._infering = false;\r\n        clearTimeout(this.timeoutId);\r\n        callback();\r\n        return;\r\n    }\r\n\r\n    if (timeout > 0 ) {\r\n        this._infering = true;\r\n        this._changes = {};\r\n        this.timeoutId = setTimeout((function() {\r\n            this._infering = false;\r\n            callback(new Error( \r\n                \"Inference timed out after \" + timeout + \" ms\"));\r\n            return;\r\n        }).bind(this), timeout);\r\n        if (typeof this._trace === \"function\") {\r\n            process.nextTick((function() {\r\n                this._trace({action: \"infer\"});\r\n            }).bind(this));\r\n        }\r\n    }\r\n\r\n    if (this._infering === false) {\r\n        callback(new Error(\"The timeout parameter must be grater than zero \" +\r\n            \"to start infering.\"));\r\n        return;\r\n    }\r\n\r\n    var proxy = this._agenda.shift();\r\n    \r\n    process.nextTick((function() {\r\n        proxy._executeRule((function(err) {\r\n            if(err) {\r\n                this._infering = false;\r\n                clearTimeout(this.timeoutId);\r\n                callback(err);\r\n                return;\r\n            }\r\n            if (this._infering) {\r\n                this.infer(0, callback);\r\n            }\r\n        }).bind(this));\r\n    }).bind(this));\r\n\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * Starts tracing the engine's operations.\r\n * @param {traceCallback} traceFunction The function called when an event\r\n *        is taking place. Events that generate a traceFunction call are:\r\n *        {@link InferenceEngine#reset}, \r\n *        {@link InferenceEngine#set},\r\n *        {@link InferenceEngine#notify},\r\n *        {@link InferenceEngine#addRule},\r\n *        {@link InferenceEngine#infer} and\r\n *        {@link EngineProxy#trace}.\r\n *\r\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\r\n */\r\nInfernalEngine.prototype.startTracing = function(traceFunction) {\r\n    if (!traceFunction) {\r\n        throw new Error(\"The parameter 'traceFunction' is mandatory.\");\r\n    }\r\n    this._trace = traceFunction;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Stops calling any trace callback that could have been defined. Has no \r\n * effect if startStracing wasn't called before.\r\n *\r\n * @returns {InfernalEngine} A reference to \"this\" object for method chaining.\r\n */\r\nInfernalEngine.prototype.stopTracing = function() {\r\n    this._trace = null;\r\n    return this;\r\n};\r\n\r\n\r\n\r\n// Private\r\n\r\nfunction applyFacts(context, source, loading) {\r\n    var sourceType = typeof source;\r\n    if ((sourceType === \"object\") && (source instanceof Date)) {\r\n        sourceType = \"date\";\r\n    }\r\n    \r\n    if ((sourceType === \"object\") && (source instanceof Array)) {\r\n        sourceType = \"array\";\r\n    }\r\n    \r\n    if (sourceType === \"function\") {\r\n        if (!loading) {\r\n            return;\r\n        } else {\r\n            this.addRule(context, source);\r\n        }\r\n\r\n    } else if (sourceType === \"object\") {\r\n        for (var property in source) {\r\n            applyFacts.call(this, context + \"/\" + property, source[property], loading);\r\n        }\r\n\r\n    } else {\r\n        this.set(context, source);\r\n    }\r\n}\r\n\r\n\r\nfunction updateAgenda(factName) {\r\n    if (this._relations[factName] !== undefined) {\r\n        var rules = this._relations[factName];\r\n        for (var ruleName in rules) {\r\n            if (rules.hasOwnProperty(ruleName) && \r\n                    (typeof this._agenda[ruleName] === \"undefined\")) {\r\n                this._agenda[ruleName] = new EngineProxy(this, ruleName);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * The inference callback function.\r\n * @callback inferenceCallback\r\n * @param {Error|*} [err] - The error information if something wrong happened.\r\n */\r\n\r\n\r\n/**\r\n * The done function tells the inference engine that the current rule is \r\n * terminated and that the next rule shall be executed. If no more rule are in\r\n * the agenda, the {@link inferenceCallback} function is called without any \r\n * parameter. If the done function is called with a parameter, the inference \r\n * immediately stops (no more rules are executed from the agenda) and the \r\n * {@link inferenceCallback} is called with the same parameter (the error).\r\n *\r\n * @callback done\r\n * @param {Error|*} [err] - The error information to send to the \r\n *        {@link inferenceCallback}\r\n */\r\n\r\n\r\n/**\r\n * The rule callback is a function that takes a single {@link done} callback \r\n * method. This method is executed in the context of an {@link EngineProxy} \r\n * instance. It is important to note that before exiting a rule function, the\r\n * done callback function has to be called to inform the engine that the next\r\n * rule in the agenda has to be executed. Usually after calling the done \r\n * function the method should exits by explicitely calling 'return' or by \r\n * letting the execution exit the scope of the function.\r\n *\r\n * @callback rule\r\n * @this EngineProxy\r\n * @param {done} done - The done callback to call when the rule terminate\r\n *                      execution.\r\n */\r\n\r\n /**\r\n  * The trace callback is called when an event changing the engine state is \r\n  * hapenning. See {@link InfernalEngine#startTracing} for details.\r\n  *\r\n  * @callback traceCallback\r\n  * @param {object} trace - The trace data.\r\n  * @param {string} trace#action - Can be either 'reset', 'set', 'notify', \r\n  *                                'addRule', 'infer' or 'trace'.\r\n  * @param {string} [trace#rule] - The rule name that generated the trace. This\r\n  *                                property is undefined if the trace was not\r\n  *                                generated during inference.\r\n  * @param {string} [trace#fact] - The fact name if the trace action is 'set' \r\n  *                                or 'notify'.\r\n  * @param {*} [trace#oldValue]  - The previous value of the fact if the trace\r\n  *                                action is 'set'.\r\n  * @param {*} [trace#newValue]  - The new value of the fact if trace action \r\n  *                                is 'set' or 'notify'.\r\n  * @param {string} [trace#message] - The message sent by the \r\n  *                                {@ling EngineProxy#trace} method if trace\r\n  *                                action is 'trace'.\r\n  */\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/index.js\n ** module id = 0\n ** module chunks = 0 1\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 1\n ** module chunks = 0 1\n **/","/**\r\n * Module agenda\r\n */\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = Agenda;\r\n\r\n/**\r\n * Create an empty Agenda.\r\n * @class\r\n */\r\nfunction Agenda() {\r\n}\r\n\r\n\r\n/**\r\n * Removes the first element from the agenda and returns it.\r\n * \r\n * @returns {EngineProxy} - The next EngineProxy to be executed.\r\n */\r\nAgenda.prototype.shift = function() {\r\n    for (var key in this) {\r\n        if (key !== \"shift\" && key !== \"isEmpty\") {\r\n            var exec = this[key];\r\n            delete this[key];\r\n            return exec;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Tells if the agenda is empty.\r\n *\r\n * @returns {boolean} True if the agenda is empty, false otherwise.\r\n */\r\nAgenda.prototype.isEmpty = function() {\r\n    for (var key in this) {\r\n        if (key !== \"shift\" && key !== \"isEmpty\") {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/agenda.js\n ** module id = 2\n ** module chunks = 0 1\n **/","\"use strict\";\r\n\r\nexports.digPath     = digPath;\r\nexports.getContext  = getContext;\r\nexports.getFullName = getFullName;\r\nexports.deepCopy    = deepCopy;\r\nexports.equals      = equals;\r\n\r\n\r\n/*\r\n * Dig a path in a root object until it finds the property that contains the \r\n * leaf element of the path.\r\n *\r\n * @param root   The root object to dig into\r\n * @param path   The path formatted with forward slashes. Supports \"..\" to move \r\n *               up one object in the hierarchy.\r\n * @param create If set to true, create the object tree while digging instead \r\n *               of returning undefined when encountering an undefined path \r\n *               element.\r\n * \r\n * @return The last object in the path along with the target leaf name in an \r\n *         object having these two properties: 'target', 'name'. If create is\r\n *         falsy, returns undefined if the path element don't exists in the \r\n *         object hierarchy.\r\n */\r\nfunction digPath(facts, path, create) {\r\n    var hierarchy = path.split(/\\//g);\r\n    var heap = [facts];\r\n    var root = facts;\r\n    var factFullName = \"\";\r\n    while (hierarchy.length > 1) {\r\n        var name = hierarchy.shift();\r\n        if (name === \"..\") {\r\n            if (heap.length !== 0) {\r\n                heap.pop();\r\n                if (heap.length === 0) {\r\n                    root = facts;\r\n                } else {\r\n                    root = heap[heap.length - 1];\r\n                }\r\n            }\r\n        } else if (name !== \"\") {\r\n            factFullName += \"/\" + name;\r\n            if (!root[name]) {\r\n                if (!create) {\r\n                    return undefined;\r\n                } else {\r\n                    root[name] = {};\r\n                }\r\n            }\r\n            root = root[name]\r\n            heap.push(root);\r\n        }\r\n    }\r\n    return {\r\n        data: heap.pop(),\r\n        name: hierarchy[0],\r\n        fullName: factFullName + \"/\" + hierarchy[0]\r\n    };\r\n}\r\n\r\n\r\nfunction getContext(currentContext, path) {\r\n    var fullName = getFullName(currentContext, path);\r\n    var lastSlash = fullName.lastIndexOf(\"/\");\r\n    return fullName.substring(0, lastSlash + 1);\r\n}\r\n\r\nfunction getFullName(context, path) {\r\n    \r\n    if (!context || context.indexOf(\"/\") !== 0) {\r\n        throw new Error(\"context must start with a '/'. Value: '\" + \r\n            context + \"'\");\r\n    }\r\n    \r\n    if (path.indexOf(\"/\") === 0) {\r\n        // Since \"path\" starts with a '/' means that \"path\" is absolute. We \r\n        // don't care about the context in that case.\r\n        return getFullName(path, \"\");\r\n    }\r\n\r\n    var contextArray = context.split(\"/\");\r\n    var pathArray = path.split(\"/\");\r\n    var contextStack = contextArray.concat(pathArray);\r\n\r\n    // Here, \"contextStack\" should contains an array of all elements in the \r\n    // path. We expect \"contextStack[0]\" to contains an empty string. That\r\n    // empty string represents the root of the path and must be there.\r\n\r\n    var stack = [];\r\n    for (var i = 0; i < contextStack.length; i++) {\r\n        var contextPart = contextStack[i];\r\n        if (i === 0 || contextPart !== \"\") {    \r\n            // Keeps initial empty contextPart (root) and skip subsequent empty\r\n            // contextStack. This will make path like \"/a/b//c\" into \"/a/b/c\".\r\n            if (contextPart === \"..\") {\r\n                if (stack.length > 1) {\r\n                    stack.pop();\r\n                }\r\n            } else {\r\n                stack.push(contextPart);\r\n            }\r\n        }\r\n    }\r\n\r\n    var fullName = \"\";\r\n    for (var i = 0; i < stack.length; i++) {\r\n        if (i > 0) {\r\n            fullName += \"/\";\r\n        }\r\n        fullName += stack[i];\r\n    }\r\n\r\n    return fullName;\r\n}\r\n\r\n\r\nfunction deepCopy(target, source) {\r\n    var sourceType = typeof source;\r\n    if (sourceType !== \"object\") {\r\n        return deepCopy({}, target);\r\n    }\r\n    if (sourceType !== \"object\" || (source instanceof Date)) {\r\n        throw new Error(\"The 'source' parameter must be an object.\");\r\n    }\r\n    for (var property in source) {\r\n        var propertyType = typeof source[property];\r\n        if ((propertyType === \"object\") &&\r\n                (source[property] !== null) &&\r\n                !(source[property] instanceof Date) &&\r\n                !(source[property] instanceof Array)) {\r\n            target[property] = target[property] || {};\r\n            deepCopy(target[property], source[property]);\r\n        } else if (propertyType !== \"function\") {\r\n            target[property] = source[property];\r\n        }\r\n    }\r\n    return target;\r\n}\r\n\r\n\r\nfunction equals(a, b) {\r\n    var aValue = a;\r\n    if (a instanceof Date) {\r\n        aValue = a.getTime(); \r\n    }\r\n    var bValue = b;\r\n    if (b instanceof Date) {\r\n        bValue = b.getTime();\r\n    }\r\n    return (aValue === bValue) && ((typeof a) === (typeof b));\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/utils.js\n ** module id = 3\n ** module chunks = 0 1\n **/","\"use strict\";\r\n\r\nvar utils = require(\"./utils\");\r\n\r\n\r\nmodule.exports = EngineProxy;\r\n\r\n/**\r\n * Creates an engine proxy class to hold a rule context of execution.\r\n * @class\r\n * @param {InfernalEngine} engine - The engine being proxied.\r\n * @param {string} - the rule name that will execute under the EngineProxy \r\n *                   context.\r\n */\r\nfunction EngineProxy(engine, ruleName) {\r\n    this.engine = engine;\r\n    this.ruleName = ruleName;\r\n    this.context = utils.getContext(\"/\", ruleName);\r\n}\r\n\r\n\r\n/**\r\n * Gets the fact value for the given factName. Note that the factName can be \r\n * a relative path to the current rule context. Usage of \"..\" allows to go\r\n * up the context stack to reach parents and sibling facts.\r\n *\r\n * @param {string} factName - The fact name.\r\n * \r\n * @returns {*} The fact value.\r\n */\r\nEngineProxy.prototype.get = function(factName) {\r\n    var fullFactName = utils.getFullName(this.context, factName);\r\n    return this.engine.get(fullFactName);\r\n};\r\n\r\n\r\n/**\r\n * Sets a fact value for the given fact name. The fact name can be a relative \r\n * path. See {@link EngineProxy#get} for details.\r\n *\r\n * @oaram {string} factName - the fact name.\r\n * @param {*} value - The value to set to the fact.\r\n *\r\n * @returns {EngineProxy} A reference to \"this\" object for method chaining.\r\n */\r\nEngineProxy.prototype.set = function(factName, value) {\r\n    var fullFactName = utils.getFullName(this.context, factName);\r\n    var oldValue = this.engine.get(fullFactName);\r\n    this.engine.set(fullFactName, value);\r\n\r\n    if ((typeof this.engine._trace === \"function\") && !utils.equals(oldValue, value)) {\r\n        var self = this;\r\n        process.nextTick(function() {\r\n            self.engine._trace({\r\n                action: \"set\",\r\n                rule: self.ruleName,\r\n                fact: fullFactName,\r\n                oldValue: oldValue,\r\n                newValue: value\r\n            });\r\n        });\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Notifies that the given fact has changed. The fact name can be a relative \r\n * path. See {@link EngineProxy#get} for details.\r\n *\r\n * @param {string} factName - The fact name.\r\n *\r\n * @returns {EngineProxy} A reference to \"this\" object for method chaining.\r\n */\r\nEngineProxy.prototype.notify = function(factName) {\r\n    var fullFactName = utils.getFullName(this.context, factName);\r\n    this.engine.notify(fullFactName);\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * This method sends a trace message to the tracing function, if tracing \r\n * is activated.\r\n *\r\n * @param {string} message - The message to send to the trace function.\r\n *\r\n * @returns {EngineProxy} A reference to \"this\" object for method chaining.\r\n */\r\nEngineProxy.prototype.trace = function(message) {\r\n    if (typeof this.engine._trace === \"function\") {\r\n        var self = this;\r\n        process.nextTick(function() {\r\n            self.engine._trace({\r\n                action: \"trace\",\r\n                rule: self.ruleName,\r\n                message: message\r\n            });\r\n        });\r\n    }\r\n    return this;\r\n}\r\n\r\n\r\n// private\r\nEngineProxy.prototype._executeRule = function(callback) {\r\n   this.engine._rules[this.ruleName].call(this, callback);\r\n   return this;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/engine-proxy.js\n ** module id = 4\n ** module chunks = 0 1\n **/"],"sourceRoot":""}