{"version":3,"sources":["webpack://InfernalEngine/webpack/universalModuleDefinition","webpack://InfernalEngine/./lib/Fact.js","webpack://InfernalEngine/./lib/RuleContext.js","webpack://InfernalEngine/./lib/index.js","webpack://InfernalEngine/./lib/infernalUtils.js","webpack://InfernalEngine/webpack/bootstrap","webpack://InfernalEngine/webpack/startup"],"names":["root","factory","exports","module","define","amd","self","path","value","Error","this","_path","_value","infernalUtils","engine","rule","facts","params","forEach","inputFact","push","_facts","get","_trace","action","inputs","result","apply","context","getContext","key","hasOwnProperty","startsWith","valueType","import","defRule","assert","retract","def","undef","RuleContext","Fact","_deleteRule","_rules","delete","_","rules","_relations","async","_infer","maxGen","_maxGen","_busy","gen","set","_agenda","size","ruleCount","currentAgenda","Map","rulectx","execute","_import","obj","targetContext","endsWith","substring","length","Date","Array","objtype","member","call","_addToAgenda","factName","has","ruleName","_deepSet","target","keys","slice","trace","_changes","Set","factpath","compiledpath","compilePath","oldValue","equals","undefined","warning","fact","newValue","add","factCount","busy","compiledPath","pathPrefix","substr","factPath","toString","rulepath","compiledRulepath","ruleContext","parameters","parseParameters","param","compiledFactpath","inputFacts","object","superBusy","replace","trim","split","clear","a","b","aValue","getTime","bValue","paramCodeWithoutEol","allParamMatch","exec","allParams","paramMatch","paramRegex","trailingTermRemovalRegex","current","next","pathCompactionRegex","currentPathRemoval","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__"],"mappings":"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","file":"infernal-engine.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"InfernalEngine\"] = factory();\n\telse\n\t\troot[\"InfernalEngine\"] = factory();\n})(self, function() {\nreturn ","\n\n\n/**\n * The Fact class stores the path and the value of a Fact instance.\n */\nclass Fact {\n    \n    /**\n     * \n     * @param {string} path The mandatory path of the fact.\n     * @param {any} value The optional value of the fact. If letft undefined, the fact will be\n     *                  retracted if it exists.\n     */\n    constructor(path, value) {\n        if (typeof path !== \"string\") {\n            throw new Error(\"The 'path' parameter must be a string.\");\n        }\n        this._path = path;\n        this._value = value;\n    }\n\n    /**\n     * Gets the fact path.\n     */\n    get path() {\n        return this._path;\n    }\n\n    /**\n     * Gets the fact value.\n     */\n    get value() {\n        return this._value;\n    }\n\n};\n\n\nmodule.exports = Fact;","const infernalUtils = require(\"./infernalUtils\");\n\n/**\n * This class is not exposed. Put a rule into its context to streamline rule execution.\n */\nclass RuleContext {\n\n\n    /**\n     * Creates an instance of the rule context with the engine, the rule and its path.\n     * \n     * @param {InfernalEngine} engine The parent InfernalEngine\n     * @param {Function} rule  The rule to execute.\n     * @param {String} path The path of the rule.\n     */\n    constructor(engine, rule, path) {\n        this.engine = engine;\n        this.rule = rule;\n        this.path = path;\n        this.facts = [];\n    }\n\n    /**\n     * Execute the rule within its context returning the \n     * resulting object to its contextualized facts.\n     */\n    async execute() {\n        let params = [];\n        this.facts.forEach(inputFact => {\n            params.push(this.engine._facts.get(inputFact));\n        });\n\n        if(this.engine._trace) {\n            this.engine._trace({\n                action: \"execute\",\n                rule: path,\n                inputs: params\n            });\n        }\n\n        let result = await this.rule.apply(null, params);\n        if (!result) {\n            return;\n        }\n\n        let context = infernalUtils.getContext(this.path);\n        for (let key in result) {\n            if (!result.hasOwnProperty(key)) continue;\n\n            if (!key.startsWith(\"#\")) {\n                let path = key.startsWith(\"/\") ? key : context + key;\n                let value = result[key];\n                let valueType = typeof value;\n                if (valueType === \"object\") {\n                    await this.engine.import(value, path);\n                } \n                else if (valueType === \"function\") {\n                    await this.engine.defRule(path, value);\n                }\n                else {\n                    await this.engine.assert(path, value);\n                }\n                continue;\n            }\n\n            let action = result[key];\n            switch (key) {\n\n                case \"#assert\":\n                    await this.engine.assert(action.path, action.value);\n                    break;\n                    \n                case \"#retract\":\n                    await this.engine.retract(action.path);\n                    break;\n\n                case \"#def\":\n                case \"#defRule\":\n                    await this.engine.def(action.path, action.value);\n                    break;\n\n                case \"#undef\":\n                case \"#undefRule\":\n                    await this.engine.undef(action.path);\n                    break;\n\n                case \"#import\":\n                    await this.engine.import(action.value, action.path);\n                    break;\n\n                default:\n                    throw new Error(`Invalid action: '${key}'.`);\n            }\n        }\n    }\n}\n\nmodule.exports = RuleContext;","\nconst infernalUtils = require(\"./infernalUtils\");\nconst RuleContext = require(\"./RuleContext\");\nconst Fact = require(\"./Fact\");\n\n\n/**\n * This is the inference engine class.\n */\nclass InfernalEngine {\n\n    /**\n     * Create a new InfernalEngine instance. \n     * @param {Number} [maxGen=50] The maximum number of agenda generation\n     *                        when executing inference. \n     * @param {Function=} trace A tracing function that will be called with a trace\n     *                          object parameter.\n     */\n    constructor(maxGen, trace) {\n        this._maxGen = maxGen || 50;\n        this._trace = trace;\n        this._busy = false;\n        this._facts = new Map();\n        this._rules = new Map();\n        this._relations = new Map();\n        this._agenda = new Map();\n        this._changes = new Set();\n    }\n\n    /**\n     * Returns the fact value for a given path.\n     * @param {String} path The full path to the desired fact.\n     * @return {Promise<*>} The fact value.\n     */\n    async peek(path) {\n        let factpath = path.startsWith(\"/\") ? path : `/${path}`;\n        let compiledpath = infernalUtils.compilePath(factpath);\n        return this._facts.get(compiledpath);\n    }\n\n    /**\n     * Asserts a new fact or update an existing fact for the given path with\n     * the provided value. Asserting a fact with an undefined value will \n     * retract the fact if it exists.\n     * @param {String} path The full path to the desired fact.\n     * @param {*} value The fact value to set, must be a scalar.\n     */\n    async assert(path, value) {\n        let factpath = path.startsWith(\"/\") ? path : `/${path}`;\n        let compiledpath = infernalUtils.compilePath(factpath);\n        var oldValue = this._facts.get(compiledpath);\n\n        if (!(value instanceof Array) && infernalUtils.equals(oldValue, value)) {\n            // GTFO if the value is not an array and the received scalar value does not change\n            // the fact value.\n            return;\n        }\n\n        let action = \"assert\";\n        if (value !== undefined) {\n            this._facts.set(compiledpath, value);\n        }\n        else {\n            if (!this._facts.has(compiledpath)) {\n                // the fact does not exist.\n                if (this._trace) {\n                    this._trace({\n                        action: \"retract\",\n                        warning: `Cannot retract undefined fact '${compiledpath}'.`\n                    });\n                }\n                return;\n            }\n            action = \"retract\";\n            this._facts.delete(compiledpath);\n            this._relations.delete(compiledpath);\n        }\n\n        if (this._trace) {\n            this._trace({\n                action: action,\n                fact: compiledpath,\n                oldValue: oldValue,\n                newValue: value\n            });\n        }\n\n        // If the path do not reference a meta-fact\n        if (!compiledpath.startsWith(\"/$\")) {\n            this._changes.add(compiledpath);\n            _addToAgenda.call(this, compiledpath);\n            if (!this._busy) {\n                await _infer.call(this);\n            }\n        }\n    }\n\n    /**\n     * Asserts all recieved facts.\n     * @param {Array<Fact>} facts A list of facts to assert at in one go.\n     */\n    async assertAll(facts) {\n        if (!(facts instanceof Array)) {\n            throw new Error(\"The 'facts' parameter must be an Array.\");\n        }\n        if (facts.length === 0) {\n            return;\n        }\n        if (this._trace) {\n            this._trace({\n                action: \"assertAll\",\n                factCount: facts.length\n            });\n        }\n        this._busy = true;\n        try {\n            for (const fact of facts) {\n                if (!(fact instanceof Fact)) {\n                    throw new Error(\"The asserted array must contains objects of class Fact only.\");\n                }\n                await this.assert(fact.path, fact.value);\n            }\n        }\n        finally {\n            this.busy = false;\n        }\n        await _infer.call(this);\n    }\n\n    /**\n     * Retracts a fact or multiple facts recursively if the path ends with '/*'.\n     * @param {String} path The path to the fact to retract.\n     */\n    async retract(path) {\n        if (!path.endsWith(\"/*\")) {\n            await this.assert(path, undefined);\n            return;\n        }\n\n        let factpath = path.startsWith(\"/\") ? path : `/${path}`;\n        let compiledPath = infernalUtils.compilePath(factpath);\n        let pathPrefix = compiledPath.substr(0, compiledPath.length - 1);\n        for (const [factPath, _] of this._facts) {\n            if (!factPath.startsWith(pathPrefix)) continue;\n            await this.assert(factPath, undefined);\n        }\n    }\n\n    /**\n     * @deprecated Use {@link IndernalEngine#def} instead.\n     * Add a rule to the engine's ruleset and launche the inference.\n     * @param {String} path The path where to save the rule at.\n     * @param {Function} rule The rule to add. Must be async.\n     */\n    async defRule(path, rule) {\n        await this.def(path, rule);\n    }\n\n    /**\n     * Add a rule to the engine's ruleset and launche the inference.\n     * @param {String} path The path where to save the rule at.\n     * @param {Function} rule The rule to add. Must be async.\n     */\n    async def(path, rule) {\n        let prefix = rule && rule.toString().substring(0,5);\n        if (prefix !== \"async\") {\n            throw new Error(\"The rule parameter must be an async function.\");\n        }\n        \n        let rulepath = path.startsWith(\"/\") ? path : `/${path}`;\n        let compiledRulepath = infernalUtils.compilePath(rulepath);\n        let context = infernalUtils.getContext(compiledRulepath);\n\n        if (this._rules.has(compiledRulepath)) {\n            throw new Error(`Can not define the rule '${compiledRulepath}' because it ` +\n                \"already exist. Call 'undef' or change the rule path.\");\n        }\n\n        let ruleContext = new RuleContext(this, rule, compiledRulepath)\n        let parameters = infernalUtils.parseParameters(rule);\n        for (const param of parameters) {\n            let factpath = param.startsWith(\"/\") ? param : context + param;\n            let compiledFactpath = infernalUtils.compilePath(factpath);\n            if (!this._relations.has(compiledFactpath))\n                this._relations.set(compiledFactpath, new Set());\n            this._relations.get(compiledFactpath).add(compiledRulepath);\n            ruleContext.facts.push(compiledFactpath);\n        }\n        \n        this._rules.set(compiledRulepath, ruleContext);\n        if (this._trace) {\n            this._trace({\n                action: \"defRule\", \n                rule: compiledRulepath,\n                inputFacts: ruleContext.facts.slice()\n            });\n        }\n\n        this._agenda.set(compiledRulepath, ruleContext);\n        if (this._trace) {\n            this._trace({\n                action: \"addToAgenda\",\n                rule: path\n            });\n        }\n\n        if (!this._busy) {\n            await _infer.call(this);\n        }\n    }\n\n\n    /**\n     * @deprecated Use {@link IndernalEngine#undef} instead.\n     * Undefine a rule at the given path or a group of rules if the path ends with '/*'.\n     * @param {String} path The path to the rule to be undefined.\n     */\n    async undefRule(path) {\n        await this.undef(path);\n    }\n\n    /**\n     * Undefine a rule at the given path or a group of rules if the path ends with '/*'.\n     * @param {String} path The path to the rule to be undefined.\n     */\n    async undef(path) {\n        let rulepath = path.startsWith(\"/\") ? path : `/${path}`;\n        let compiledRulepath = infernalUtils.compilePath(rulepath);\n\n        if (!compiledRulepath.endsWith(\"/*\")) {\n            _deleteRule.call(this, compiledRulepath);\n            return;\n        }\n\n        let pathPrefix = compiledRulepath.substr(0, compiledRulepath.length - 1);\n        for (const [path, _] of this._rules) {\n            if (!path.startsWith(pathPrefix)) continue;\n            _deleteRule.call(this, path);\n        }\n    }\n\n    /**\n     * Import the given Javascript object into the engine. Scalar values and arrays as facts,\n     * functions as rules. Launches the inference on any new rules and any existing rules\n     * triggered by importing the object facts. Infers only when eveything have been imported.\n     * @param {Object}  obj     The object to import.\n     * @param {String}  context The path where the object will be imported.\n     */\n    async import(obj, context) {\n        if (this._trace) {\n            this._trace({\n                action: \"import\", \n                object: obj\n            });\n        }\n        let superBusy = this._busy; // true when called while infering.\n        this._busy = true;\n        try {\n            await _import.call(this, obj, context || \"\");\n            if (!superBusy) {\n                // not already infering, start the inference.\n                await _infer.call(this);\n            }\n        }\n        finally {\n            if (!superBusy) {\n                // Not already infering, reset the busy state.\n                this._busy = false;\n            }\n        }\n    }\n\n    /**\n     * Export internal facts from the given optional path as a JSON object. Do not export rules.\n     * @param {String} [context=\"/\"] The context to export as an object.\n     * @return {object} a JSON object representation of the engine internal state.\n     */\n    async export(context) {\n        let targetContext = context || \"/\";\n        if (!targetContext.startsWith(\"/\")) {\n            targetContext = `/${targetContext}`;\n        }\n        let obj = {};\n        for (const [key, value] of this._facts) {\n            if (key.startsWith(targetContext)) {\n                let subkeys = key\n                    .substring(targetContext.length)\n                    .replace(/\\//g, \" \")\n                    .trim()\n                    .split(\" \");\n                _deepSet(obj, subkeys, value);\n            }\n        }\n        return obj;\n    }\n\n\n    /**\n     * Exports all changed facts since the last call to exportChanges or\n     * [reset]{@link InfernalEngine#reset} as a Javascript object. Reset the change tracker.\n     * @return a JSON object containing the cumulative changes since last call.\n     */\n    async exportChanges() {\n        let obj = {};\n        for (const key of this._changes) {\n            let subkeys = key\n                .replace(/\\//g, \" \")\n                .trim()\n                .split(\" \");\n            _deepSet(obj, subkeys, this._facts.get(key));\n        }\n        this._changes.clear();\n        return obj;\n    }\n\n    /**\n     * Resets the change tracker.\n     */\n    async reset() {\n        this._changes.clear();\n    }\n\n    /**\n     * Create a new Fact with the given path and value.\n     * @param {string} path Mandatory path of the fact.\n     * @param {any} value Value of the fact, can be 'undefined' to retract the given fact.\n     */\n    static fact(path, value) {\n        return new Fact(path, value);\n    }\n\n}\n\n\n\n// Private\n\n\nfunction _deleteRule(path) {\n    if (this._trace) {\n        this._trace({\n            action: \"undefRule\", \n            rule: path\n        });\n    }\n    this._rules.delete(path);\n\n    // TODO: Target relations using the rule's parameter instead of looping blindly.\n    for (const [_, rules] of this._relations) {\n        rules.delete(path);\n    }\n}\n\n // Execute inference and return a promise. At the begining of the inference, sets the \n // '/$/maxGen' fact to make it available to rules that would be interested in this value.\n // Upon each loop, the engine sets the '/$/gen' value indicating the agenda generation the\n // inference is currently at.\nasync function _infer() {\n    if (this._trace) {\n        this._trace({\n            action: \"infer\",\n            maxGen: this._maxGen\n        });\n    }\n\n    this._busy = true;\n    let gen = 0;\n    this._facts.set(\"/$/maxGen\", this._maxGen); //metafacts do not trigger rules\n\n    try {\n        while (gen < this._maxGen && this._agenda.size > 0) {\n            gen++;\n            this._facts.set(\"/$/gen\", gen); // metafacts do not trigger rules\n            if (this._trace) {\n                this._trace({\n                    action: \"executeAgenda\",\n                    gen: gen,\n                    ruleCount: this._agenda.size\n                });\n            }\n            let currentAgenda = this._agenda;\n            this._agenda = new Map();\n            for (const [_, rulectx] of currentAgenda) {\n                await rulectx.execute();\n            }\n        }\n    }\n    finally {\n        this._busy = false;\n    }\n\n    if (gen == this._maxGen) {\n        throw new Error(\"Inference not completed because maximum depth \" +\n            `reached (${this._maxGen}). Please review for infinite loop or set the ` +\n            \"maxDepth property to a larger value.\");\n    }\n}\n\n\nasync function _import(obj, context) {\n    let targetContext = context;\n    if (context.endsWith(\"/\")) {\n        targetContext = context.substring(0, context.length-1);\n    }\n\n    // Set an object that needs to be handled like scalar value.\n    if (obj instanceof Date || obj instanceof Array) {\n        return await this.assert(targetContext, obj);\n    }\n\n    const objtype = typeof obj;\n\n    // Handle rules as they come by.\n    if (objtype === \"function\") {\n        return await this.defRule(targetContext, obj);\n    }\n\n    // Set scalar value\n    if (objtype !== \"object\") {\n        return await this.assert(targetContext, obj);\n    }\n\n    // Drill down into the object to add other facts and rules.\n    for (let member in obj) {\n        await _import.call(this,\n            obj[member],\n            `${targetContext}/${member}`);\n    }\n}\n\nfunction _addToAgenda(factName) {\n    if (this._relations.has(factName)) {\n        let rules = this._relations.get(factName);\n        rules.forEach(ruleName => {\n            this._agenda.set(ruleName, this._rules.get(ruleName));\n            if (this._trace) {\n                this._trace({\n                    action: \"addToAgenda\",\n                    rule: ruleName\n                });\n            }\n        });\n    }\n}\n\nfunction _deepSet(target, keys, value) {\n    let key = keys[0];\n    if (keys.length === 1) {\n        target[key] = value;\n        return;\n    }\n    if (typeof target[key] === \"undefined\") {\n        target[key] = {};\n    }\n    _deepSet(target[key], keys.slice(1), value)\n}\n\n\nmodule.exports = InfernalEngine;","\nmodule.exports = {\n    equals: equals,\n    parseParameters: parseFactPaths,\n    getContext: getContext,\n    compilePath: compilePath\n};\n\n//https://regex101.com/r/zYhguP/6/\nconst paramRegex = /(?:\\/\\*?@ *([\\w/.]+?) *\\*\\/ *\\w+,?)|[(,]? *(\\w+) *[,)]?/g;\nconst trailingTermRemovalRegex = /[^/]+?$/;\nconst pathCompactionRegex = /\\/[^/.]+\\/\\.\\./;\nconst currentPathRemoval = /\\.\\//g;\n\n/**\n * Compare two values and return true if they are equal. Fix date comparison issue and insure\n * both types are the same.\n * \n * @param {*} a The first value used to compare.\n * @param {*} b The second value used to caompare.\n */\nfunction equals(a, b) {\n    var aValue = a;\n    if (a instanceof Date) {\n        aValue = a.getTime(); \n    }\n    var bValue = b;\n    if (b instanceof Date) {\n        bValue = b.getTime();\n    }\n    return (aValue === bValue);\n}\n\n/**\n * Generator that parses all fact paths derived from the given rule parameters. Either return the\n * parameter name or the path contained by the optional attribute comment. Single parameter lambda\n * function must put the parameter between parenthesis to be parsed properly.\n * \n * @example\n * \n * Using an attribute comment:\n * \n *     async function(/¤@ /path/to/fact ¤/ param1, param2) {}\n * \n * In the above example: \n * \n *   1) ¤ replaces * because using * and / one after the other ends the documentation comment.\n *   2) returned fact paths would be ['/path/to/fact', 'param2']\n * \n * @param {AsyncFunction} rule The rule \n */\nfunction* parseFactPaths(rule) {\n    let allParamsRegex = /\\((.+?)\\)|= ?(?:async)? ?(\\w+) ?=>/g;\n    let paramCode = (rule.toString().split(')')[0] + ')');\n    let paramCodeWithoutEol = paramCode.replace(/\\s+/g, \" \");\n    let allParamMatch = allParamsRegex.exec(paramCodeWithoutEol);\n    if (!allParamMatch) return;\n\n    let allParams = allParamMatch[1];\n    let paramMatch = paramRegex.exec(allParams);\n    do {\n        yield (paramMatch[1] || paramMatch[2]);\n        paramMatch = paramRegex.exec(allParams);\n    } \n    while (paramMatch)\n}\n\n\n/**\n * Extracts the context from the fact or rule name. Must be a compiled path, not a path that\n * contains \"../\" or \"./\".\n * \n * @example\n * \n * Given the rule path: '/path/to/some/rule'\n * The returned value would be: '/path/to/some'\n * \n * @param {String} compiledPath The compiled path to extract the context from.\n */\nfunction getContext(compiledPath) {\n    return compiledPath.replace(trailingTermRemovalRegex, \"\");\n}\n\n/**\n * Create a compacted fact name from a given fact name. Path do not end with a trailing '/'.\n * \n *  '../' Denote the parent term. Move up one term in the context or path.\n *  './'  Denote the current term. Removed from the context or path.\n * \n * Examples: \n * \n *  '/a/given/../correct/./path' is compiled to '/a/correct/path'\n * \n * @param {String} path The path or context to compile into a context.\n */\nfunction compilePath(path) {\n    let current = path;\n    let next = path.replace(pathCompactionRegex, \"\");\n    while (next != current) {\n        current = next;\n        next = current.replace(pathCompactionRegex, \"\");\n    }\n    if (current.startsWith(\"/..\")) {\n        throw new Error(`Unable to compile the path '${path}' properly.`);\n    }\n    return current.replace(currentPathRemoval, \"\");\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(568);\n"],"sourceRoot":""}