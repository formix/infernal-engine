{"version":3,"sources":["webpack://InfernalEngine/webpack/universalModuleDefinition","webpack://InfernalEngine/./lib/Fact.js","webpack://InfernalEngine/./lib/RuleContext.js","webpack://InfernalEngine/./lib/index.js","webpack://InfernalEngine/./lib/infernalUtils.js","webpack://InfernalEngine/webpack/bootstrap","webpack://InfernalEngine/webpack/startup"],"names":["root","factory","exports","module","define","amd","self","path","value","Error","this","_path","_value","infernalUtils","engine","rule","facts","params","forEach","inputFact","push","_facts","get","_trace","action","inputs","result","apply","context","getContext","key","hasOwnProperty","startsWith","valueType","import","defRule","assert","retract","undefRule","RuleContext","Fact","_deleteRule","_rules","delete","_","rules","_relations","async","_infer","maxGen","_maxGen","_busy","gen","set","_agenda","size","ruleCount","currentAgenda","Map","rulectx","execute","_import","obj","targetContext","endsWith","substring","length","Date","Array","objtype","member","call","_addToAgenda","factName","has","ruleName","_deepSet","target","keys","slice","trace","_changes","Set","factpath","compiledpath","compilePath","oldValue","equals","undefined","warning","fact","newValue","add","factCount","busy","compiledPath","pathPrefix","substr","factPath","toString","rulepath","compiledRulepath","ruleContext","parameters","parseParameters","param","compiledFactpath","inputFacts","object","superBusy","replace","trim","split","clear","a","b","aValue","getTime","bValue","paramCodeWithoutEol","allParamMatch","exec","allParams","paramMatch","paramRegex","trailingTermRemovalRegex","current","next","pathCompactionRegex","currentPathRemoval","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__"],"mappings":"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","file":"infernal-engine.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"InfernalEngine\"] = factory();\n\telse\n\t\troot[\"InfernalEngine\"] = factory();\n})(self, function() {\nreturn ","\n\n\n/**\n * The Fact class stores the path and the value of a Fact instance.\n */\nclass Fact {\n    \n    /**\n     * \n     * @param {string} path The mandatory path of the fact.\n     * @param {any} value The optional value of the fact. If letft undefined, the fact will be\n     *                  retracted if it exists.\n     */\n    constructor(path, value) {\n        if (typeof path !== \"string\") {\n            throw new Error(\"The 'path' parameter must be a string.\");\n        }\n        this._path = path;\n        this._value = value;\n    }\n\n    /**\n     * Gets the fact path.\n     */\n    get path() {\n        return this._path;\n    }\n\n    /**\n     * Gets the fact value.\n     */\n    get value() {\n        return this._value;\n    }\n\n};\n\n\nmodule.exports = Fact;","const infernalUtils = require(\"./infernalUtils\");\n\n/**\n * This class is not exposed. Put a rule into its context to streamline rule execution.\n */\nclass RuleContext {\n\n\n    /**\n     * Creates an instance of the rule context with the engine, the rule and its path.\n     * \n     * @param {InfernalEngine} engine The parent InfernalEngine\n     * @param {Function} rule  The rule to execute.\n     * @param {String} path The path of the rule.\n     */\n    constructor(engine, rule, path) {\n        this.engine = engine;\n        this.rule = rule;\n        this.path = path;\n        this.facts = [];\n    }\n\n    /**\n     * Execute the rule within its context returning the \n     * resulting object to their respective contextualized facts.\n     */\n    async execute() {\n        let params = [];\n        this.facts.forEach(inputFact => {\n            params.push(this.engine._facts.get(inputFact));\n        });\n\n        if(this.engine._trace) {\n            this.engine._trace({\n                action: \"execute\",\n                rule: path,\n                inputs: params\n            });\n        }\n\n        let result = await this.rule.apply(null, params);\n        if (result) {\n            let context = infernalUtils.getContext(this.path);\n            for (let key in result) {\n                if (!result.hasOwnProperty(key)) continue;\n\n                if (!key.startsWith(\"#\")) {\n                    let path = key.startsWith(\"/\") ? key : context + key;\n                    let value = result[key];\n                    let valueType = typeof value;\n                    if (valueType === \"object\") {\n                        await this.engine.import(value, path);\n                    } \n                    else if (valueType === \"function\") {\n                        await this.engine.defRule(path, value);\n                    }\n                    else {\n                        await this.engine.assert(path, value);\n                    }\n                    continue;\n                }\n\n                let action = result[key];\n                switch (key) {\n\n                    case \"#assert\":\n                        await this.engine.assert(action.path, action.value);\n                        break;\n                        \n                    case \"#retract\":\n                        await this.engine.retract(action.path);\n                        break;\n\n                    case \"#defRule\":\n                        await this.engine.defRule(action.path, action.value);\n                        break;\n\n                    case \"#undefRule\":\n                        await this.engine.undefRule(action.path);\n                        break;\n\n                    case \"#import\":\n                        await this.engine.import(action.value, action.path);\n                        break;\n\n                    default:\n                        throw new Error(`Invalid action: '${key}'.`);\n                }\n            }\n        }\n    }\n}\n\nmodule.exports = RuleContext;","\nconst infernalUtils = require(\"./infernalUtils\");\nconst RuleContext = require(\"./RuleContext\");\nconst Fact = require(\"./Fact\");\n\n\n/**\n * This is the inference engine class.\n */\nclass InfernalEngine {\n\n    /**\n     * Create a new InfernalEngine instance. \n     * @param {Number} [maxGen=50] The maximum number of agenda generation\n     *                        when executing inference. \n     * @param {Function=} trace A tracing function that will be called with a trace\n     *                          object parameter.\n     */\n    constructor(maxGen, trace) {\n        this._maxGen = maxGen || 50;\n        this._trace = trace;\n        this._busy = false;\n        this._facts = new Map();\n        this._rules = new Map();\n        this._relations = new Map();\n        this._agenda = new Map();\n        this._changes = new Set();\n    }\n\n    /**\n     * Returns the fact value for a given path.\n     * @param {String} path The full path to the desired fact.\n     * @return {Promise<*>} The fact value.\n     */\n    async peek(path) {\n        let factpath = path.startsWith(\"/\") ? path : `/${path}`;\n        let compiledpath = infernalUtils.compilePath(factpath);\n        return this._facts.get(compiledpath);\n    }\n\n    /**\n     * Asserts a new fact or update an existing fact for the given path with\n     * the provided value. Asserting a fact with an undefined value will \n     * retract the fact if it exists.\n     * @param {String} path The full path to the desired fact.\n     * @param {*} value The fact value to set, must be a scalar.\n     */\n    async assert(path, value) {\n        let factpath = path.startsWith(\"/\") ? path : `/${path}`;\n        let compiledpath = infernalUtils.compilePath(factpath);\n        var oldValue = this._facts.get(compiledpath);\n\n        if (!(value instanceof Array) && infernalUtils.equals(oldValue, value)) {\n            // GTFO if the value is not an array and the received scalar value does not change\n            // the fact value.\n            return;\n        }\n\n        let action = \"assert\";\n        if (value !== undefined) {\n            this._facts.set(compiledpath, value);\n        }\n        else {\n            if (!this._facts.has(compiledpath)) {\n                // the fact does not exist.\n                if (this._trace) {\n                    this._trace({\n                        action: \"retract\",\n                        warning: `Cannot retract undefined fact '${compiledpath}'.`\n                    });\n                }\n                return;\n            }\n            action = \"retract\";\n            this._facts.delete(compiledpath);\n            this._relations.delete(compiledpath);\n        }\n\n        if (this._trace) {\n            this._trace({\n                action: action,\n                fact: compiledpath,\n                oldValue: oldValue,\n                newValue: value\n            });\n        }\n\n        // If the path do not reference a meta-fact\n        if (!compiledpath.startsWith(\"/$\")) {\n            this._changes.add(compiledpath);\n            _addToAgenda.call(this, compiledpath);\n            if (!this._busy) {\n                await _infer.call(this);\n            }\n        }\n    }\n\n    /**\n     * Asserts all recieved facts.\n     * @param {Array<Fact>} facts A list of facts to assert at in one go.\n     */\n    async assertAll(facts) {\n        if (!(facts instanceof Array)) {\n            throw new Error(\"The 'facts' parameter must be an Array.\");\n        }\n        if (facts.length === 0) {\n            return;\n        }\n        if (this._trace) {\n            this._trace({\n                action: \"assertAll\",\n                factCount: facts.length\n            });\n        }\n        this._busy = true;\n        try {\n            for (const fact of facts) {\n                if (!(fact instanceof Fact)) {\n                    throw new Error(\"The asserted array must contains objects of type Fact only.\");\n                }\n                await this.assert(fact.path, fact.value);\n            }\n        }\n        finally {\n            this.busy = false;\n        }\n        await _infer.call(this);\n    }\n\n    /**\n     * Retracts a fact or multiple facts recursively if the path ends with '/*'.\n     * @param {String} path The path to the fact to retract.\n     */\n    async retract(path) {\n        if (!path.endsWith(\"/*\")) {\n            await this.assert(path, undefined);\n            return;\n        }\n\n        let factpath = path.startsWith(\"/\") ? path : `/${path}`;\n        let compiledPath = infernalUtils.compilePath(factpath);\n        let pathPrefix = compiledPath.substr(0, compiledPath.length - 1);\n        for (const [factPath, _] of this._facts) {\n            if (!factPath.startsWith(pathPrefix)) continue;\n            await this.assert(factPath, undefined);\n        }\n    }\n\n    /**\n     * Add a rule to the engine's ruleset and launche the inference.\n     * @param {String} path The path where to save the rule at.\n     * @param {Function} rule The rule to add. Must be async.\n     */\n    async defRule(path, rule) {\n        let prefix = rule && rule.toString().substring(0,5);\n        if (prefix !== \"async\") {\n            throw new Error(\"The rule parameter must be an async function.\");\n        }\n        \n        let rulepath = path.startsWith(\"/\") ? path : `/${path}`;\n        let compiledRulepath = infernalUtils.compilePath(rulepath);\n        let context = infernalUtils.getContext(compiledRulepath);\n\n        if (this._rules.has(compiledRulepath)) {\n            throw new Error(`Can not define the rule '${compiledRulepath}' because it ` +\n                \"already exist. Call 'undefRule' or change the rule path.\");\n        }\n\n        let ruleContext = new RuleContext(this, rule, compiledRulepath)\n        let parameters = infernalUtils.parseParameters(rule);\n        for (const param of parameters) {\n            let factpath = param.startsWith(\"/\") ? param : context + param;\n            let compiledFactpath = infernalUtils.compilePath(factpath);\n            if (!this._relations.has(compiledFactpath))\n                this._relations.set(compiledFactpath, new Set());\n            this._relations.get(compiledFactpath).add(compiledRulepath);\n            ruleContext.facts.push(compiledFactpath);\n        }\n        \n        this._rules.set(compiledRulepath, ruleContext);\n        if (this._trace) {\n            this._trace({\n                action: \"defRule\", \n                rule: compiledRulepath,\n                inputFacts: ruleContext.facts.slice()\n            });\n        }\n\n        this._agenda.set(compiledRulepath, ruleContext);\n        if (this._trace) {\n            this._trace({\n                action: \"addToAgenda\",\n                rule: path\n            });\n        }\n\n        if (!this._busy) {\n            await _infer.call(this);\n        }\n    }\n\n    /**\n     * Undefine a rule at the given path or a group of rules if the path ends with '/*'.\n     * @param {String} path The path to the rule to be undefined.\n     */\n    async undefRule(path) {\n        let rulepath = path.startsWith(\"/\") ? path : `/${path}`;\n        let compiledRulepath = infernalUtils.compilePath(rulepath);\n\n        if (!compiledRulepath.endsWith(\"/*\")) {\n            _deleteRule.call(this, compiledRulepath);\n            return;\n        }\n\n        let pathPrefix = compiledRulepath.substr(0, compiledRulepath.length - 1);\n        for (const [path, _] of this._rules) {\n            if (!path.startsWith(pathPrefix)) continue;\n            _deleteRule.call(this, path);\n        }\n    }\n\n    /**\n     * Import the given Javascript object into the engine. Scalar values and arrays as facts,\n     * functions as rules. Launches the inference on any new rules and any existing rules\n     * triggered by importing the object facts. Infers only when eveything have been imported.\n     * @param {Object}  obj     The object to import.\n     * @param {String}  context The path where the object will be imported.\n     */\n    async import(obj, context) {\n        if (this._trace) {\n            this._trace({\n                action: \"import\", \n                object: obj\n            });\n        }\n        let superBusy = this._busy; // true when called while infering.\n        this._busy = true;\n        try {\n            await _import.call(this, obj, context || \"\");\n            if (!superBusy) {\n                // not already infering, start the inference.\n                await _infer.call(this);\n            }\n        }\n        finally {\n            if (!superBusy) {\n                // Not already infering, reset the busy state.\n                this._busy = false;\n            }\n        }\n    }\n\n    /**\n     * Export internal facts from the given optional path as a JSON object. Do not export rules.\n     * @param {String} [context=\"/\"] The context to export as an object.\n     * @return {object} a JSON object representation of the engine internal state.\n     */\n    async export(context) {\n        let targetContext = context || \"/\";\n        if (!targetContext.startsWith(\"/\")) {\n            targetContext = `/${targetContext}`;\n        }\n        let obj = {};\n        for (const [key, value] of this._facts) {\n            if (key.startsWith(targetContext)) {\n                let subkeys = key\n                    .substring(targetContext.length)\n                    .replace(/\\//g, \" \")\n                    .trim()\n                    .split(\" \");\n                _deepSet(obj, subkeys, value);\n            }\n        }\n        return obj;\n    }\n\n\n    /**\n     * Exports all changed facts since the last call to exportChanges or\n     * [reset]{@link InfernalEngine#reset} as a Javascript object. Reset the change tracker.\n     * @return a JSON object containing the cumulative changes since last call.\n     */\n    async exportChanges() {\n        let obj = {};\n        for (const key of this._changes) {\n            let subkeys = key\n                .replace(/\\//g, \" \")\n                .trim()\n                .split(\" \");\n            _deepSet(obj, subkeys, this._facts.get(key));\n        }\n        this._changes.clear();\n        return obj;\n    }\n\n    /**\n     * Resets the change tracker.\n     */\n    async reset() {\n        this._changes.clear();\n    }\n\n    /**\n     * Create a new Fact with the given path and value.\n     * @param {string} path Mandatory path of the fact.\n     * @param {any} value Value of the fact, can be 'undefined' to retract the given fact.\n     */\n    static fact(path, value) {\n        return new Fact(path, value);\n    }\n\n}\n\n\n\n// Private\n\n\nfunction _deleteRule(path) {\n    if (this._trace) {\n        this._trace({\n            action: \"undefRule\", \n            rule: path\n        });\n    }\n    this._rules.delete(path);\n\n    // TODO: Target relations using the rule's parameter instead of looping blindly.\n    for (const [_, rules] of this._relations) {\n        rules.delete(path);\n    }\n}\n\n // Execute inference and return a promise. At the begining of the inference, sets the \n // '/$/maxGen' fact to make it available to rules that would be interested in this value.\n // Upon each loop, the engine sets the '/$/gen' value indicating the agenda generation the\n // inference is currently at.\nasync function _infer() {\n    if (this._trace) {\n        this._trace({\n            action: \"infer\",\n            maxGen: this._maxGen\n        });\n    }\n\n    this._busy = true;\n    let gen = 0;\n    this._facts.set(\"/$/maxGen\", this._maxGen); //metafacts do not trigger rules\n\n    try {\n        while (gen < this._maxGen && this._agenda.size > 0) {\n            gen++;\n            this._facts.set(\"/$/gen\", gen); // metafacts do not trigger rules\n            if (this._trace) {\n                this._trace({\n                    action: \"executeAgenda\",\n                    gen: gen,\n                    ruleCount: this._agenda.size\n                });\n            }\n            let currentAgenda = this._agenda;\n            this._agenda = new Map();\n            for (const [_, rulectx] of currentAgenda) {\n                await rulectx.execute();\n            }\n        }\n    }\n    finally {\n        this._busy = false;\n    }\n\n    if (gen == this._maxGen) {\n        throw new Error(\"Inference not completed because maximum depth \" +\n            `reached (${this._maxGen}). Please review for infinite loop or set the ` +\n            \"maxDepth property to a larger value.\");\n    }\n}\n\n\nasync function _import(obj, context) {\n    let targetContext = context;\n    if (context.endsWith(\"/\")) {\n        targetContext = context.substring(0, context.length-1);\n    }\n\n    // Set an object that needs to be handled like scalar value.\n    if (obj instanceof Date || obj instanceof Array) {\n        return await this.assert(targetContext, obj);\n    }\n\n    const objtype = typeof obj;\n\n    // Handle rules as they come by.\n    if (objtype === \"function\") {\n        return await this.defRule(targetContext, obj);\n    }\n\n    // Set scalar value\n    if (objtype !== \"object\") {\n        return await this.assert(targetContext, obj);\n    }\n\n    // Drill down into the object to add other facts and rules.\n    for (let member in obj) {\n        await _import.call(this,\n            obj[member],\n            `${targetContext}/${member}`);\n    }\n}\n\nfunction _addToAgenda(factName) {\n    if (this._relations.has(factName)) {\n        let rules = this._relations.get(factName);\n        rules.forEach(ruleName => {\n            this._agenda.set(ruleName, this._rules.get(ruleName));\n            if (this._trace) {\n                this._trace({\n                    action: \"addToAgenda\",\n                    rule: ruleName\n                });\n            }\n        });\n    }\n}\n\nfunction _deepSet(target, keys, value) {\n    let key = keys[0];\n    if (keys.length === 1) {\n        target[key] = value;\n        return;\n    }\n    if (typeof target[key] === \"undefined\") {\n        target[key] = {};\n    }\n    _deepSet(target[key], keys.slice(1), value)\n}\n\n\nmodule.exports = InfernalEngine;","\nmodule.exports = {\n    equals: equals,\n    parseParameters: parseFactPaths,\n    getContext: getContext,\n    compilePath: compilePath\n};\n\n//https://regex101.com/r/zYhguP/6/\nconst paramRegex = /(?:\\/\\*?@ *([\\w/.]+?) *\\*\\/ *\\w+,?)|[(,]? *(\\w+) *[,)]?/g;\nconst trailingTermRemovalRegex = /[^/]+?$/;\nconst pathCompactionRegex = /\\/[^/.]+\\/\\.\\./;\nconst currentPathRemoval = /\\.\\//g;\n\n/**\n * Compare two values and return true if they are equal. Fix date comparison issue and insure\n * both types are the same.\n * \n * @param {*} a The first value used to compare.\n * @param {*} b The second value used to caompare.\n */\nfunction equals(a, b) {\n    var aValue = a;\n    if (a instanceof Date) {\n        aValue = a.getTime(); \n    }\n    var bValue = b;\n    if (b instanceof Date) {\n        bValue = b.getTime();\n    }\n    return (aValue === bValue);\n}\n\n/**\n * Generator that parses all fact paths derived from the given rule parameters. Either return the\n * parameter name or the path contained by the optional attribute comment. Single parameter lambda\n * function must put the parameter between parenthesis to be parsed properly.\n * \n * @example\n * \n * Using an attribute comment:\n * \n *     async function(/¤@ /path/to/fact ¤/ param1, param2) {}\n * \n * In the above example: \n * \n *   1) ¤ replaces * because using * and / one after the other ends the documentation comment.\n *   2) returned fact paths would be ['/path/to/fact', 'param2']\n * \n * @param {AsyncFunction} rule The rule \n */\nfunction* parseFactPaths(rule) {\n    let allParamsRegex = /\\((.+?)\\)|= ?(?:async)? ?(\\w+) ?=>/g;\n    let paramCode = (rule.toString().split(')')[0] + ')');\n    let paramCodeWithoutEol = paramCode.replace(/\\s+/g, \" \");\n    let allParamMatch = allParamsRegex.exec(paramCodeWithoutEol);\n    if (!allParamMatch) return;\n\n    let allParams = allParamMatch[1];\n    let paramMatch = paramRegex.exec(allParams);\n    do {\n        yield (paramMatch[1] || paramMatch[2]);\n        paramMatch = paramRegex.exec(allParams);\n    } \n    while (paramMatch)\n}\n\n\n/**\n * Extracts the context from the fact or rule name. Must be a compiled path, not a path that\n * contains \"../\" or \"./\".\n * \n * @example\n * \n * Given the rule path: '/path/to/some/rule'\n * The returned value would be: '/path/to/some'\n * \n * @param {String} compiledPath The compiled path to extract the context from.\n */\nfunction getContext(compiledPath) {\n    return compiledPath.replace(trailingTermRemovalRegex, \"\");\n}\n\n/**\n * Create a compacted fact name from a given fact name. Path do not end with a trailing '/'.\n * \n *  '../' Denote the parent term. Move up one term in the context or path.\n *  './'  Denote the current term. Removed from the context or path.\n * \n * Examples: \n * \n *  '/a/given/../correct/./path' is compiled to '/a/correct/path'\n * \n * @param {String} path The path or context to compile into a context.\n */\nfunction compilePath(path) {\n    let current = path;\n    let next = path.replace(pathCompactionRegex, \"\");\n    while (next != current) {\n        current = next;\n        next = current.replace(pathCompactionRegex, \"\");\n    }\n    if (current.startsWith(\"/..\")) {\n        throw new Error(`Unable to compile the path '${path}' properly.`);\n    }\n    return current.replace(currentPathRemoval, \"\");\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(568);\n"],"sourceRoot":""}