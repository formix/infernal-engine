{"version":3,"file":"infernal-engine.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAwB,eAAID,IAE5BD,EAAqB,eAAIC,GAC1B,CATD,CASGK,MAAM,KACT,O,WC6BAH,EAAOD,QAjCP,MAQIK,YAAYC,EAAMC,GACd,GAAoB,iBAATD,EACP,MAAM,IAAIE,MAAM,0CAEpBC,KAAKC,MAAQJ,EACbG,KAAKE,OAASJ,CAClB,CAKID,WACA,OAAOG,KAAKC,KAChB,CAKIH,YACA,OAAOE,KAAKE,MAChB,E,gBClCJ,MAAMC,EAAgB,EAAQ,IAiG9BX,EAAOD,QA5FP,MAUIK,YAAYQ,EAAQC,EAAMR,GACtBG,KAAKI,OAASA,EACdJ,KAAKK,KAAOA,EACZL,KAAKH,KAAOA,EACZG,KAAKM,MAAQ,EACjB,CAMAC,gBACI,IAAIC,EAAS,GACbR,KAAKM,MAAMG,SAAQC,IACfF,EAAOG,KAAKX,KAAKI,OAAOQ,OAAOC,IAAIH,GAAW,IAG/CV,KAAKI,OAAOU,QACXd,KAAKI,OAAOU,OAAO,CACfC,OAAQ,UACRV,KAAML,KAAKH,KACXmB,OAAQR,IAIhB,IAAIS,QAAejB,KAAKK,KAAKa,MAAM,KAAMV,GACzC,IAAKS,EACD,OAGJ,IAAIE,EAAUhB,EAAciB,WAAWpB,KAAKH,MAC5C,IAAK,IAAIwB,KAAOJ,EAAQ,CACpB,IAAKA,EAAOK,eAAeD,GAAM,SAEjC,IAAKA,EAAIE,WAAW,KAAM,CACtB,IAAI1B,EAAOwB,EAAIE,WAAW,KAAOF,EAAMF,EAAUE,EAC7CvB,EAAQmB,EAAOI,GACfG,EAAYrB,EAAcsB,OAAO3B,GACnB,WAAd0B,QACMxB,KAAKI,OAAOsB,OAAO5B,EAAOD,GAEb,aAAd2B,QACCxB,KAAKI,OAAOuB,QAAQ9B,EAAMC,SAG1BE,KAAKI,OAAOwB,OAAO/B,EAAMC,GAEnC,QACJ,CAEA,IAAIiB,EAASE,EAAOI,GACpB,OAAQA,GAEJ,IAAK,gBACKrB,KAAKI,OAAOwB,OAAOb,EAAOlB,KAAMkB,EAAOjB,OAC7C,MAEJ,IAAK,iBACKE,KAAKI,OAAOyB,QAAQd,EAAOlB,MACjC,MAEJ,IAAK,OACL,IAAK,iBACKG,KAAKI,OAAO0B,IAAIf,EAAOlB,KAAMkB,EAAOjB,OAC1C,MAEJ,IAAK,SACL,IAAK,mBACKE,KAAKI,OAAO2B,MAAMhB,EAAOlB,MAC/B,MAEJ,IAAK,gBACKG,KAAKI,OAAOsB,OAAOX,EAAOjB,MAAOiB,EAAOlB,MAC9C,MAEJ,QACI,MAAM,IAAIE,MAAM,oBAAoBsB,OAEhD,CACJ,E,gBC7FJ,MAAMlB,EAAgB,EAAQ,IACxB6B,EAAc,EAAQ,KACtBC,EAAO,EAAQ,KA+UrB,SAASC,EAAYrC,GACbG,KAAKc,QACLd,KAAKc,OAAO,CACRC,OAAQ,YACRV,KAAMR,IAGdG,KAAKmC,OAAOC,OAAOvC,GAGnB,IAAK,MAAOwC,EAAGC,KAAUtC,KAAKuC,WAC1BD,EAAMF,OAAOvC,EAErB,CAMAU,eAAeiC,IACPxC,KAAKc,QACLd,KAAKc,OAAO,CACRC,OAAQ,QACR0B,OAAQzC,KAAK0C,UAIrB1C,KAAK2C,OAAQ,EACb,IAAIC,EAAM,EACV5C,KAAKY,OAAOiC,IAAI,YAAa7C,KAAK0C,SAElC,IACI,KAAOE,EAAM5C,KAAK0C,SAAW1C,KAAK8C,QAAQC,KAAO,GAAG,CAChDH,IACA5C,KAAKY,OAAOiC,IAAI,SAAUD,GACtB5C,KAAKc,QACLd,KAAKc,OAAO,CACRC,OAAQ,gBACR6B,IAAKA,EACLI,UAAWhD,KAAK8C,QAAQC,OAGhC,IAAIE,EAAgBjD,KAAK8C,QACzB9C,KAAK8C,QAAU,IAAII,IACnB,IAAK,MAAOb,EAAGc,KAAYF,QACjBE,EAAQC,SAEtB,CAIJ,CAFA,QACIpD,KAAK2C,OAAQ,CACjB,CAEA,GAAIC,GAAO5C,KAAK0C,QACZ,MAAM,IAAI3C,MACN,0DAAYC,KAAK0C,4FAG7B,CAGAnC,eAAe8C,EAAQC,EAAKnC,GACxB,IAAIoC,EAAgBpC,EAMpB,GALIA,EAAQqC,SAAS,OACjBD,EAAgBpC,EAAQsC,UAAU,EAAGtC,EAAQuC,OAAO,IAIpDJ,aAAeK,MAAQL,aAAeM,MACtC,aAAa5D,KAAK4B,OAAO2B,EAAeD,GAG5C,MAAMO,SAAiBP,EAGvB,GAAgB,aAAZO,EACA,aAAa7D,KAAK2B,QAAQ4B,EAAeD,GAI7C,GAAgB,WAAZO,EACA,aAAa7D,KAAK4B,OAAO2B,EAAeD,GAI5C,IAAK,IAAIQ,KAAUR,QACTD,EAAQU,KAAK/D,KACfsD,EAAIQ,GACJ,GAAGP,KAAiBO,IAEhC,CAEA,SAASE,EAAaC,GACdjE,KAAKuC,WAAW2B,IAAID,IACRjE,KAAKuC,WAAW1B,IAAIoD,GAC1BxD,SAAQ0D,IACVnE,KAAK8C,QAAQD,IAAIsB,EAAUnE,KAAKmC,OAAOtB,IAAIsD,IACvCnE,KAAKc,QACLd,KAAKc,OAAO,CACRC,OAAQ,cACRV,KAAM8D,GAEd,GAGZ,CAEA,SAASC,EAASC,EAAQC,EAAMxE,GAC5B,IAAIuB,EAAMiD,EAAK,GACK,IAAhBA,EAAKZ,aAIkB,IAAhBW,EAAOhD,KACdgD,EAAOhD,GAAO,CAAC,GAEnB+C,EAASC,EAAOhD,GAAMiD,EAAKC,MAAM,GAAIzE,IANjCuE,EAAOhD,GAAOvB,CAOtB,CAGAN,EAAOD,QAjcP,MASIK,YAAY6C,EAAQ+B,GAChBxE,KAAK0C,QAAUD,GAAU,GACzBzC,KAAKc,OAAS0D,EACdxE,KAAK2C,OAAQ,EACb3C,KAAKY,OAAS,IAAIsC,IAClBlD,KAAKmC,OAAS,IAAIe,IAClBlD,KAAKuC,WAAa,IAAIW,IACtBlD,KAAK8C,QAAU,IAAII,IACnBlD,KAAKyE,SAAW,IAAIC,GACxB,CAOAnE,WAAWV,GACP,IAAI8E,EAAW9E,EAAK0B,WAAW,KAAO1B,EAAO,IAAIA,IAC7C+E,EAAezE,EAAc0E,YAAYF,GAC7C,OAAO3E,KAAKY,OAAOC,IAAI+D,EAC3B,CASArE,aAAaV,EAAMC,GACf,IAAI6E,EAAW9E,EAAK0B,WAAW,KAAO1B,EAAO,IAAIA,IAC7C+E,EAAezE,EAAc0E,YAAYF,GAC7C,IAAIG,EAAW9E,KAAKY,OAAOC,IAAI+D,GAE/B,KAAM9E,aAAiB8D,QAAUzD,EAAc4E,OAAOD,EAAUhF,GAG5D,OAGJ,IAAIiB,EAAS,SACb,QAAciE,IAAVlF,EACAE,KAAKY,OAAOiC,IAAI+B,EAAc9E,OAE7B,CACD,IAAKE,KAAKY,OAAOsD,IAAIU,GAQjB,YANI5E,KAAKc,QACLd,KAAKc,OAAO,CACRC,OAAQ,UACRkE,QAAS,kCAAkCL,SAKvD7D,EAAS,UACTf,KAAKY,OAAOwB,OAAOwC,GACnB5E,KAAKuC,WAAWH,OAAOwC,EAC3B,CAEI5E,KAAKc,QACLd,KAAKc,OAAO,CACRC,OAAQA,EACRmE,KAAMN,EACNE,SAAUA,EACVK,SAAUrF,IAKb8E,EAAarD,WAAW,QACzBvB,KAAKyE,SAASW,IAAIR,GAClBZ,EAAaD,KAAK/D,KAAM4E,GACnB5E,KAAK2C,aACAH,EAAOuB,KAAK/D,MAG9B,CAMAO,gBAAgBD,GACZ,KAAMA,aAAiBsD,OACnB,MAAM,IAAI7D,MAAM,2CAEpB,GAAqB,IAAjBO,EAAMoD,OAAV,CAGI1D,KAAKc,QACLd,KAAKc,OAAO,CACRC,OAAQ,YACRsE,UAAW/E,EAAMoD,SAGzB1D,KAAK2C,OAAQ,EACb,IACI,IAAK,MAAMuC,KAAQ5E,EAAO,CACtB,KAAM4E,aAAgBjD,GAClB,MAAM,IAAIlC,MAAM,sEAEdC,KAAK4B,OAAOsD,EAAKrF,KAAMqF,EAAKpF,MACtC,CAIJ,CAFA,QACIE,KAAKsF,MAAO,CAChB,OACM9C,EAAOuB,KAAK/D,KAnBlB,CAoBJ,CAMAO,cAAcV,GACV,IAAKA,EAAK2D,SAAS,MAEf,kBADMxD,KAAK4B,OAAO/B,OAAMmF,GAI5B,IAAIL,EAAW9E,EAAK0B,WAAW,KAAO1B,EAAO,IAAIA,IAC7C0F,EAAepF,EAAc0E,YAAYF,GACzCa,EAAaD,EAAaE,OAAO,EAAGF,EAAa7B,OAAS,GAC9D,IAAK,MAAOgC,EAAUrD,KAAMrC,KAAKY,OACxB8E,EAASnE,WAAWiE,UACnBxF,KAAK4B,OAAO8D,OAAUV,EAEpC,CAQAzE,cAAcV,EAAMQ,SACVL,KAAK8B,IAAIjC,EAAMQ,EACzB,CAOAE,UAAUV,EAAMQ,GAEZ,GAAe,WADFA,GAAQA,EAAKsF,WAAWlC,UAAU,EAAE,IAE7C,MAAM,IAAI1D,MAAM,iDAGpB,IAAI6F,EAAW/F,EAAK0B,WAAW,KAAO1B,EAAO,IAAIA,IAC7CgG,EAAmB1F,EAAc0E,YAAYe,GAC7CzE,EAAUhB,EAAciB,WAAWyE,GAEvC,GAAI7F,KAAKmC,OAAO+B,IAAI2B,GAChB,MAAM,IAAI9F,MAAM,4BAA4B8F,sEAIhD,IAAIC,EAAc,IAAI9D,EAAYhC,KAAMK,EAAMwF,GAC1CE,EAAa5F,EAAc6F,gBAAgB3F,GAC/C,IAAK,MAAM4F,KAASF,EAAY,CAC5B,IAAIpB,EAAWsB,EAAM1E,WAAW,KAAO0E,EAAQ9E,EAAU8E,EACrDC,EAAmB/F,EAAc0E,YAAYF,GAC5C3E,KAAKuC,WAAW2B,IAAIgC,IACrBlG,KAAKuC,WAAWM,IAAIqD,EAAkB,IAAIxB,KAC9C1E,KAAKuC,WAAW1B,IAAIqF,GAAkBd,IAAIS,GAC1CC,EAAYxF,MAAMK,KAAKuF,EAC3B,CAEAlG,KAAKmC,OAAOU,IAAIgD,EAAkBC,GAC9B9F,KAAKc,QACLd,KAAKc,OAAO,CACRC,OAAQ,UACRV,KAAMwF,EACNM,WAAYL,EAAYxF,MAAMiE,UAItCvE,KAAK8C,QAAQD,IAAIgD,EAAkBC,GAC/B9F,KAAKc,QACLd,KAAKc,OAAO,CACRC,OAAQ,cACRV,KAAMR,IAITG,KAAK2C,aACAH,EAAOuB,KAAK/D,KAE1B,CAQAO,gBAAgBV,SACNG,KAAK+B,MAAMlC,EACrB,CAMAU,YAAYV,GACR,IAAI+F,EAAW/F,EAAK0B,WAAW,KAAO1B,EAAO,IAAIA,IAC7CgG,EAAmB1F,EAAc0E,YAAYe,GAEjD,IAAKC,EAAiBrC,SAAS,MAE3B,YADAtB,EAAY6B,KAAK/D,KAAM6F,GAI3B,IAAIL,EAAaK,EAAiBJ,OAAO,EAAGI,EAAiBnC,OAAS,GACtE,IAAK,MAAO7D,EAAMwC,KAAMrC,KAAKmC,OACpBtC,EAAK0B,WAAWiE,IACrBtD,EAAY6B,KAAK/D,KAAMH,EAE/B,CASAU,aAAa+C,EAAKnC,GACVnB,KAAKc,QACLd,KAAKc,OAAO,CACRC,OAAQ,SACRqF,OAAQ9C,IAGhB,IAAI+C,EAAYrG,KAAK2C,MACrB3C,KAAK2C,OAAQ,EACb,UACUU,EAAQU,KAAK/D,KAAMsD,EAAKnC,GAAW,IACpCkF,SAEK7D,EAAOuB,KAAK/D,KAQ1B,CALA,QACSqG,IAEDrG,KAAK2C,OAAQ,EAErB,CACJ,CAOApC,aAAaY,GACT,IAAIoC,EAAgBpC,GAAW,IAC1BoC,EAAchC,WAAW,OAC1BgC,EAAgB,IAAIA,KAExB,IAAID,EAAM,CAAC,EACX,IAAK,MAAOjC,EAAKvB,KAAUE,KAAKY,OACxBS,EAAIE,WAAWgC,IAMfa,EAASd,EALKjC,EACToC,UAAUF,EAAcG,QACxB4C,QAAQ,MAAO,KACfC,OACAC,MAAM,KACY1G,GAG/B,OAAOwD,CACX,CAQA/C,sBACI,IAAI+C,EAAM,CAAC,EACX,IAAK,MAAMjC,KAAOrB,KAAKyE,SAKnBL,EAASd,EAJKjC,EACTiF,QAAQ,MAAO,KACfC,OACAC,MAAM,KACYxG,KAAKY,OAAOC,IAAIQ,IAG3C,OADArB,KAAKyE,SAASgC,QACPnD,CACX,CAKA/C,cACIP,KAAKyE,SAASgC,OAClB,CAOAC,YAAY7G,EAAMC,GACd,OAAO,IAAImC,EAAKpC,EAAMC,EAC1B,E,SCxUJN,EAAOD,QAAU,CACbwF,OAoBJ,SAAgB4B,EAAGC,GACf,IAAIC,EAASF,EACTA,aAAahD,OACbkD,EAASF,EAAEG,WAEf,IAAIC,EAASH,EAIb,OAHIA,aAAajD,OACboD,EAASH,EAAEE,WAEPD,IAAWE,CACvB,EA7BIf,gBA8DJ,UAAyB3F,GACrB,IAEI2G,GADa3G,EAAKsF,WAAWa,MAAM,KAAK,GAAK,KACbF,QAAQ,OAAQ,KAChDW,EAHiB,sCAGcC,KAAKF,GACxC,IAAKC,EAAe,OAEpB,IAAIE,EAAYF,EAAc,GAC1BG,EAAaC,EAAWH,KAAKC,GACjC,SACWC,EAAW,IAAMA,EAAW,GACnCA,EAAaC,EAAWH,KAAKC,SAE1BC,EACX,EA3EIhG,WAyFJ,SAAoBmE,GAChB,OAAOA,EAAae,QAAQgB,EAA0B,GAC1D,EA1FIzC,YAwGJ,SAAqBhF,GACjB,IAAI0H,EAAU1H,EACV2H,EAAO3H,EAAKyG,QAAQmB,EAAqB,IAC7C,KAAOD,GAAQD,GACXA,EAAUC,EACVA,EAAOD,EAAQjB,QAAQmB,EAAqB,IAEhD,GAAIF,EAAQhG,WAAW,OACnB,MAAM,IAAIxB,MAAM,+BAA+BF,gBAEnD,OAAO0H,EAAQjB,QAAQoB,EAAoB,GAC/C,EAlHIjG,OA6BJ,SAAiBkG,GACb,OAAIA,aAAahE,KACN,OAEFgE,aAAa/D,MACX,eAGO+D,CAEtB,GAnCA,MAAMN,EAAa,2DACbC,EAA2B,UAC3BG,EAAsB,iBACtBC,EAAqB,O,GCZvBE,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqB9C,IAAjB+C,EACH,OAAOA,EAAaxI,QAGrB,IAAIC,EAASoI,EAAyBE,GAAY,CAGjDvI,QAAS,CAAC,GAOX,OAHAyI,EAAoBF,GAAUtI,EAAQA,EAAOD,QAASsI,GAG/CrI,EAAOD,OACf,CCnB0BsI,CAAoB,K,MDF1CD,C","sources":["webpack://InfernalEngine/webpack/universalModuleDefinition","webpack://InfernalEngine/./lib/Fact.js","webpack://InfernalEngine/./lib/RuleContext.js","webpack://InfernalEngine/./lib/index.js","webpack://InfernalEngine/./lib/infernalUtils.js","webpack://InfernalEngine/webpack/bootstrap","webpack://InfernalEngine/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"InfernalEngine\"] = factory();\n\telse\n\t\troot[\"InfernalEngine\"] = factory();\n})(self, () => {\nreturn ","\n\n\n/**\n * The Fact class stores the path and the value of a Fact instance.\n */\nclass Fact {\n    \n    /**\n     * \n     * @param {string} path The mandatory path of the fact.\n     * @param {any} value The optional value of the fact. If letft undefined, the fact will be\n     *                  retracted if it exists.\n     */\n    constructor(path, value) {\n        if (typeof path !== \"string\") {\n            throw new Error(\"The 'path' parameter must be a string.\");\n        }\n        this._path = path;\n        this._value = value;\n    }\n\n    /**\n     * Gets the fact path.\n     */\n    get path() {\n        return this._path;\n    }\n\n    /**\n     * Gets the fact value.\n     */\n    get value() {\n        return this._value;\n    }\n\n};\n\n\nmodule.exports = Fact;","const infernalUtils = require(\"./infernalUtils\");\n\n/**\n * This class is not exposed. Put a rule into its context to streamline rule execution.\n */\nclass RuleContext {\n\n\n    /**\n     * Creates an instance of the rule context with the engine, the rule and its path.\n     * \n     * @param {InfernalEngine} engine The parent InfernalEngine\n     * @param {Function} rule  The rule to execute.\n     * @param {String} path The path of the rule.\n     */\n    constructor(engine, rule, path) {\n        this.engine = engine;\n        this.rule = rule;\n        this.path = path;\n        this.facts = [];\n    }\n\n    /**\n     * Execute the rule within its context returning the \n     * resulting object to its contextualized facts.\n     */\n    async execute() {\n        let params = [];\n        this.facts.forEach(inputFact => {\n            params.push(this.engine._facts.get(inputFact));\n        });\n\n        if(this.engine._trace) {\n            this.engine._trace({\n                action: \"execute\",\n                rule: this.path,\n                inputs: params\n            });\n        }\n\n        let result = await this.rule.apply(null, params);\n        if (!result) {\n            return;\n        }\n\n        let context = infernalUtils.getContext(this.path);\n        for (let key in result) {\n            if (!result.hasOwnProperty(key)) continue;\n\n            if (!key.startsWith(\"#\")) {\n                let path = key.startsWith(\"/\") ? key : context + key;\n                let value = result[key];\n                let valueType = infernalUtils.typeof(value);\n                if (valueType === \"object\") {\n                    await this.engine.import(value, path);\n                } \n                else if (valueType === \"function\") {\n                    await this.engine.defRule(path, value);\n                }\n                else {\n                    await this.engine.assert(path, value);\n                }\n                continue;\n            }\n\n            let action = result[key];\n            switch (key) {\n\n                case \"#assert\":\n                    await this.engine.assert(action.path, action.value);\n                    break;\n                    \n                case \"#retract\":\n                    await this.engine.retract(action.path);\n                    break;\n\n                case \"#def\":\n                case \"#defRule\":\n                    await this.engine.def(action.path, action.value);\n                    break;\n\n                case \"#undef\":\n                case \"#undefRule\":\n                    await this.engine.undef(action.path);\n                    break;\n\n                case \"#import\":\n                    await this.engine.import(action.value, action.path);\n                    break;\n\n                default:\n                    throw new Error(`Invalid action: '${key}'.`);\n            }\n        }\n    }\n}\n\nmodule.exports = RuleContext;","\nconst infernalUtils = require(\"./infernalUtils\");\nconst RuleContext = require(\"./RuleContext\");\nconst Fact = require(\"./Fact\");\n\n\n/**\n * This is the inference engine class.\n */\nclass InfernalEngine {\n\n    /**\n     * Create a new InfernalEngine instance. \n     * @param {Number} [maxGen=50] The maximum number of agenda generation\n     *                        when executing inference. \n     * @param {Function=} trace A tracing function that will be called with a trace\n     *                          object parameter.\n     */\n    constructor(maxGen, trace) {\n        this._maxGen = maxGen || 50;\n        this._trace = trace;\n        this._busy = false;\n        this._facts = new Map();\n        this._rules = new Map();\n        this._relations = new Map();\n        this._agenda = new Map();\n        this._changes = new Set();\n    }\n\n    /**\n     * Returns the fact value for a given path.\n     * @param {String} path The full path to the desired fact.\n     * @return {Promise<*>} The fact value.\n     */\n    async peek(path) {\n        let factpath = path.startsWith(\"/\") ? path : `/${path}`;\n        let compiledpath = infernalUtils.compilePath(factpath);\n        return this._facts.get(compiledpath);\n    }\n\n    /**\n     * Asserts a new fact or update an existing fact for the given path with\n     * the provided value. Asserting a fact with an undefined value will \n     * retract the fact if it exists.\n     * @param {String} path The full path to the desired fact.\n     * @param {*} value The fact value to set, must be a scalar.\n     */\n    async assert(path, value) {\n        let factpath = path.startsWith(\"/\") ? path : `/${path}`;\n        let compiledpath = infernalUtils.compilePath(factpath);\n        var oldValue = this._facts.get(compiledpath);\n\n        if (!(value instanceof Array) && infernalUtils.equals(oldValue, value)) {\n            // GTFO if the value is not an array and the received scalar value does not change\n            // the fact value.\n            return;\n        }\n\n        let action = \"assert\";\n        if (value !== undefined) {\n            this._facts.set(compiledpath, value);\n        }\n        else {\n            if (!this._facts.has(compiledpath)) {\n                // the fact does not exist.\n                if (this._trace) {\n                    this._trace({\n                        action: \"retract\",\n                        warning: `Cannot retract undefined fact '${compiledpath}'.`\n                    });\n                }\n                return;\n            }\n            action = \"retract\";\n            this._facts.delete(compiledpath);\n            this._relations.delete(compiledpath);\n        }\n\n        if (this._trace) {\n            this._trace({\n                action: action,\n                fact: compiledpath,\n                oldValue: oldValue,\n                newValue: value\n            });\n        }\n\n        // If the path do not reference a meta-fact\n        if (!compiledpath.startsWith(\"/$\")) {\n            this._changes.add(compiledpath);\n            _addToAgenda.call(this, compiledpath);\n            if (!this._busy) {\n                await _infer.call(this);\n            }\n        }\n    }\n\n    /**\n     * Asserts all recieved facts.\n     * @param {Array<Fact>} facts A list of facts to assert at in one go.\n     */\n    async assertAll(facts) {\n        if (!(facts instanceof Array)) {\n            throw new Error(\"The 'facts' parameter must be an Array.\");\n        }\n        if (facts.length === 0) {\n            return;\n        }\n        if (this._trace) {\n            this._trace({\n                action: \"assertAll\",\n                factCount: facts.length\n            });\n        }\n        this._busy = true;\n        try {\n            for (const fact of facts) {\n                if (!(fact instanceof Fact)) {\n                    throw new Error(\"The asserted array must contains objects of class Fact only.\");\n                }\n                await this.assert(fact.path, fact.value);\n            }\n        }\n        finally {\n            this.busy = false;\n        }\n        await _infer.call(this);\n    }\n\n    /**\n     * Retracts a fact or multiple facts recursively if the path ends with '/*'.\n     * @param {String} path The path to the fact to retract.\n     */\n    async retract(path) {\n        if (!path.endsWith(\"/*\")) {\n            await this.assert(path, undefined);\n            return;\n        }\n\n        let factpath = path.startsWith(\"/\") ? path : `/${path}`;\n        let compiledPath = infernalUtils.compilePath(factpath);\n        let pathPrefix = compiledPath.substr(0, compiledPath.length - 1);\n        for (const [factPath, _] of this._facts) {\n            if (!factPath.startsWith(pathPrefix)) continue;\n            await this.assert(factPath, undefined);\n        }\n    }\n\n    /**\n     * @deprecated Use {@link InfernalEngine#def} instead.\n     * Add a rule to the engine's ruleset and launche the inference.\n     * @param {String} path The path where to save the rule at.\n     * @param {Function} rule The rule to add. Must be async.\n     */\n    async defRule(path, rule) {\n        await this.def(path, rule);\n    }\n\n    /**\n     * Add a rule to the engine's ruleset and launche the inference.\n     * @param {String} path The path where to save the rule at.\n     * @param {Function} rule The rule to add. Must be async.\n     */\n    async def(path, rule) {\n        let prefix = rule && rule.toString().substring(0,5);\n        if (prefix !== \"async\") {\n            throw new Error(\"The rule parameter must be an async function.\");\n        }\n        \n        let rulepath = path.startsWith(\"/\") ? path : `/${path}`;\n        let compiledRulepath = infernalUtils.compilePath(rulepath);\n        let context = infernalUtils.getContext(compiledRulepath);\n\n        if (this._rules.has(compiledRulepath)) {\n            throw new Error(`Can not define the rule '${compiledRulepath}' because it ` +\n                \"already exist. Call 'undef' or change the rule path.\");\n        }\n\n        let ruleContext = new RuleContext(this, rule, compiledRulepath)\n        let parameters = infernalUtils.parseParameters(rule);\n        for (const param of parameters) {\n            let factpath = param.startsWith(\"/\") ? param : context + param;\n            let compiledFactpath = infernalUtils.compilePath(factpath);\n            if (!this._relations.has(compiledFactpath))\n                this._relations.set(compiledFactpath, new Set());\n            this._relations.get(compiledFactpath).add(compiledRulepath);\n            ruleContext.facts.push(compiledFactpath);\n        }\n        \n        this._rules.set(compiledRulepath, ruleContext);\n        if (this._trace) {\n            this._trace({\n                action: \"defRule\", \n                rule: compiledRulepath,\n                inputFacts: ruleContext.facts.slice()\n            });\n        }\n\n        this._agenda.set(compiledRulepath, ruleContext);\n        if (this._trace) {\n            this._trace({\n                action: \"addToAgenda\",\n                rule: path\n            });\n        }\n\n        if (!this._busy) {\n            await _infer.call(this);\n        }\n    }\n\n\n    /**\n     * @deprecated Use {@link InfernalEngine#undef} instead.\n     * Undefine a rule at the given path or a group of rules if the path ends with '/*'.\n     * @param {String} path The path to the rule to be undefined.\n     */\n    async undefRule(path) {\n        await this.undef(path);\n    }\n\n    /**\n     * Undefine a rule at the given path or a group of rules if the path ends with '/*'.\n     * @param {String} path The path to the rule to be undefined.\n     */\n    async undef(path) {\n        let rulepath = path.startsWith(\"/\") ? path : `/${path}`;\n        let compiledRulepath = infernalUtils.compilePath(rulepath);\n\n        if (!compiledRulepath.endsWith(\"/*\")) {\n            _deleteRule.call(this, compiledRulepath);\n            return;\n        }\n\n        let pathPrefix = compiledRulepath.substr(0, compiledRulepath.length - 1);\n        for (const [path, _] of this._rules) {\n            if (!path.startsWith(pathPrefix)) continue;\n            _deleteRule.call(this, path);\n        }\n    }\n\n    /**\n     * Import the given Javascript object into the engine. Scalar values and arrays as facts,\n     * functions as rules. Launches the inference on any new rules and any existing rules\n     * triggered by importing the object facts. Infers only when eveything have been imported.\n     * @param {Object}  obj     The object to import.\n     * @param {String}  context The path where the object will be imported.\n     */\n    async import(obj, context) {\n        if (this._trace) {\n            this._trace({\n                action: \"import\", \n                object: obj\n            });\n        }\n        let superBusy = this._busy; // true when called while infering.\n        this._busy = true;\n        try {\n            await _import.call(this, obj, context || \"\");\n            if (!superBusy) {\n                // not already infering, start the inference.\n                await _infer.call(this);\n            }\n        }\n        finally {\n            if (!superBusy) {\n                // Not already infering, reset the busy state.\n                this._busy = false;\n            }\n        }\n    }\n\n    /**\n     * Export internal facts from the given optional path as a JSON object. Do not export rules.\n     * @param {String} [context=\"/\"] The context to export as an object.\n     * @return {object} a JSON object representation of the engine internal state.\n     */\n    async export(context) {\n        let targetContext = context || \"/\";\n        if (!targetContext.startsWith(\"/\")) {\n            targetContext = `/${targetContext}`;\n        }\n        let obj = {};\n        for (const [key, value] of this._facts) {\n            if (key.startsWith(targetContext)) {\n                let subkeys = key\n                    .substring(targetContext.length)\n                    .replace(/\\//g, \" \")\n                    .trim()\n                    .split(\" \");\n                _deepSet(obj, subkeys, value);\n            }\n        }\n        return obj;\n    }\n\n\n    /**\n     * Exports all changed facts since the last call to exportChanges or\n     * [reset]{@link InfernalEngine#reset} as a Javascript object. Reset the change tracker.\n     * @return a JSON object containing the cumulative changes since last call.\n     */\n    async exportChanges() {\n        let obj = {};\n        for (const key of this._changes) {\n            let subkeys = key\n                .replace(/\\//g, \" \")\n                .trim()\n                .split(\" \");\n            _deepSet(obj, subkeys, this._facts.get(key));\n        }\n        this._changes.clear();\n        return obj;\n    }\n\n    /**\n     * Resets the change tracker.\n     */\n    async reset() {\n        this._changes.clear();\n    }\n\n    /**\n     * Create a new Fact with the given path and value.\n     * @param {string} path Mandatory path of the fact.\n     * @param {any} value Value of the fact, can be 'undefined' to retract the given fact.\n     */\n    static fact(path, value) {\n        return new Fact(path, value);\n    }\n\n}\n\n\n\n// Private\n\n\nfunction _deleteRule(path) {\n    if (this._trace) {\n        this._trace({\n            action: \"undefRule\", \n            rule: path\n        });\n    }\n    this._rules.delete(path);\n\n    // TODO: Target relations using the rule's parameter instead of looping blindly.\n    for (const [_, rules] of this._relations) {\n        rules.delete(path);\n    }\n}\n\n // Execute inference and return a promise. At the begining of the inference, sets the \n // '/$/maxGen' fact to make it available to rules that would be interested in this value.\n // Upon each loop, the engine sets the '/$/gen' value indicating the agenda generation the\n // inference is currently at.\nasync function _infer() {\n    if (this._trace) {\n        this._trace({\n            action: \"infer\",\n            maxGen: this._maxGen\n        });\n    }\n\n    this._busy = true;\n    let gen = 0;\n    this._facts.set(\"/$/maxGen\", this._maxGen); //metafacts do not trigger rules\n\n    try {\n        while (gen < this._maxGen && this._agenda.size > 0) {\n            gen++;\n            this._facts.set(\"/$/gen\", gen); // metafacts do not trigger rules\n            if (this._trace) {\n                this._trace({\n                    action: \"executeAgenda\",\n                    gen: gen,\n                    ruleCount: this._agenda.size\n                });\n            }\n            let currentAgenda = this._agenda;\n            this._agenda = new Map();\n            for (const [_, rulectx] of currentAgenda) {\n                await rulectx.execute();\n            }\n        }\n    }\n    finally {\n        this._busy = false;\n    }\n\n    if (gen == this._maxGen) {\n        throw new Error(\"Inference not completed because maximum depth \" +\n            `reached (${this._maxGen}). Please review for infinite loop or set the ` +\n            \"maxDepth property to a larger value.\");\n    }\n}\n\n\nasync function _import(obj, context) {\n    let targetContext = context;\n    if (context.endsWith(\"/\")) {\n        targetContext = context.substring(0, context.length-1);\n    }\n\n    // Set an object that needs to be handled like scalar value.\n    if (obj instanceof Date || obj instanceof Array) {\n        return await this.assert(targetContext, obj);\n    }\n\n    const objtype = typeof obj;\n\n    // Handle rules as they come by.\n    if (objtype === \"function\") {\n        return await this.defRule(targetContext, obj);\n    }\n\n    // Set scalar value\n    if (objtype !== \"object\") {\n        return await this.assert(targetContext, obj);\n    }\n\n    // Drill down into the object to add other facts and rules.\n    for (let member in obj) {\n        await _import.call(this,\n            obj[member],\n            `${targetContext}/${member}`);\n    }\n}\n\nfunction _addToAgenda(factName) {\n    if (this._relations.has(factName)) {\n        let rules = this._relations.get(factName);\n        rules.forEach(ruleName => {\n            this._agenda.set(ruleName, this._rules.get(ruleName));\n            if (this._trace) {\n                this._trace({\n                    action: \"addToAgenda\",\n                    rule: ruleName\n                });\n            }\n        });\n    }\n}\n\nfunction _deepSet(target, keys, value) {\n    let key = keys[0];\n    if (keys.length === 1) {\n        target[key] = value;\n        return;\n    }\n    if (typeof target[key] === \"undefined\") {\n        target[key] = {};\n    }\n    _deepSet(target[key], keys.slice(1), value)\n}\n\n\nmodule.exports = InfernalEngine;","\nmodule.exports = {\n    equals: equals,\n    parseParameters: parseFactPaths,\n    getContext: getContext,\n    compilePath: compilePath,\n    typeof: _typeof\n};\n\n//https://regex101.com/r/zYhguP/6/\nconst paramRegex = /(?:\\/\\*?@ *([\\w/.]+?) *\\*\\/ *\\w+,?)|[(,]? *(\\w+) *[,)]?/g;\nconst trailingTermRemovalRegex = /[^/]+?$/;\nconst pathCompactionRegex = /\\/[^/.]+\\/\\.\\./;\nconst currentPathRemoval = /\\.\\//g;\n\n/**\n * Compare two values and return true if they are equal. Fix date comparison issue and insure\n * both types are the same.\n * \n * @param {*} a The first value used to compare.\n * @param {*} b The second value used to caompare.\n */\nfunction equals(a, b) {\n    var aValue = a;\n    if (a instanceof Date) {\n        aValue = a.getTime(); \n    }\n    var bValue = b;\n    if (b instanceof Date) {\n        bValue = b.getTime();\n    }\n    return (aValue === bValue);\n}\n\n\nfunction _typeof(o) {\n    if (o instanceof Date) {\n        return \"date\";\n    }\n    else if (o instanceof Array) {\n        return \"array\";\n    }\n    else {\n        return typeof o;\n    }\n}\n\n/**\n * Generator that parses all fact paths derived from the given rule parameters. Either return the\n * parameter name or the path contained by the optional attribute comment. Single parameter lambda\n * function must put the parameter between parenthesis to be parsed properly.\n * \n * @example\n * \n * Using an attribute comment:\n * \n *     async function(/¤@ /path/to/fact ¤/ param1, param2) {}\n * \n * In the above example: \n * \n *   1) ¤ replaces * because using * and / one after the other ends the documentation comment.\n *   2) returned fact paths would be ['/path/to/fact', 'param2']\n * \n * @param {AsyncFunction} rule The rule \n */\nfunction* parseFactPaths(rule) {\n    let allParamsRegex = /\\((.+?)\\)|= ?(?:async)? ?(\\w+) ?=>/g;\n    let paramCode = (rule.toString().split(')')[0] + ')');\n    let paramCodeWithoutEol = paramCode.replace(/\\s+/g, \" \");\n    let allParamMatch = allParamsRegex.exec(paramCodeWithoutEol);\n    if (!allParamMatch) return;\n\n    let allParams = allParamMatch[1];\n    let paramMatch = paramRegex.exec(allParams);\n    do {\n        yield (paramMatch[1] || paramMatch[2]);\n        paramMatch = paramRegex.exec(allParams);\n    } \n    while (paramMatch)\n}\n\n\n/**\n * Extracts the context from the fact or rule name. Must be a compiled path, not a path that\n * contains \"../\" or \"./\".\n * \n * @example\n * \n * Given the rule path: '/path/to/some/rule'\n * The returned value would be: '/path/to/some'\n * \n * @param {String} compiledPath The compiled path to extract the context from.\n */\nfunction getContext(compiledPath) {\n    return compiledPath.replace(trailingTermRemovalRegex, \"\");\n}\n\n/**\n * Create a compacted fact name from a given fact name. Path do not end with a trailing '/'.\n * \n *  '../' Denote the parent term. Move up one term in the context or path.\n *  './'  Denote the current term. Removed from the context or path.\n * \n * Examples: \n * \n *  '/a/given/../correct/./path' is compiled to '/a/correct/path'\n * \n * @param {String} path The path or context to compile into a context.\n */\nfunction compilePath(path) {\n    let current = path;\n    let next = path.replace(pathCompactionRegex, \"\");\n    while (next != current) {\n        current = next;\n        next = current.replace(pathCompactionRegex, \"\");\n    }\n    if (current.startsWith(\"/..\")) {\n        throw new Error(`Unable to compile the path '${path}' properly.`);\n    }\n    return current.replace(currentPathRemoval, \"\");\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(568);\n"],"names":["root","factory","exports","module","define","amd","self","constructor","path","value","Error","this","_path","_value","infernalUtils","engine","rule","facts","async","params","forEach","inputFact","push","_facts","get","_trace","action","inputs","result","apply","context","getContext","key","hasOwnProperty","startsWith","valueType","typeof","import","defRule","assert","retract","def","undef","RuleContext","Fact","_deleteRule","_rules","delete","_","rules","_relations","_infer","maxGen","_maxGen","_busy","gen","set","_agenda","size","ruleCount","currentAgenda","Map","rulectx","execute","_import","obj","targetContext","endsWith","substring","length","Date","Array","objtype","member","call","_addToAgenda","factName","has","ruleName","_deepSet","target","keys","slice","trace","_changes","Set","factpath","compiledpath","compilePath","oldValue","equals","undefined","warning","fact","newValue","add","factCount","busy","compiledPath","pathPrefix","substr","factPath","toString","rulepath","compiledRulepath","ruleContext","parameters","parseParameters","param","compiledFactpath","inputFacts","object","superBusy","replace","trim","split","clear","static","a","b","aValue","getTime","bValue","paramCodeWithoutEol","allParamMatch","exec","allParams","paramMatch","paramRegex","trailingTermRemovalRegex","current","next","pathCompactionRegex","currentPathRemoval","o","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}