!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.InfernalEngine=e():t.InfernalEngine=e()}(self,(function(){return t={980:t=>{t.exports=class{constructor(t,e){if("string"!=typeof t)throw new Error("The 'path' parameter must be a string.");this._path=t,this._value=e}get path(){return this._path}get value(){return this._value}}},743:(t,e,s)=>{const a=s(74);t.exports=class{constructor(t,e,s){this.engine=t,this.rule=e,this.path=s,this.facts=[]}async execute(){let t=[];this.facts.forEach((e=>{t.push(this.engine._facts.get(e))})),this.engine._trace&&this.engine._trace({action:"execute",rule:path,inputs:t});let e=await this.rule.apply(null,t);if(e){let t=a.getContext(this.path);for(let s in e){if(!e.hasOwnProperty(s))continue;if(!s.startsWith("#")){let a=s.startsWith("/")?s:t+s,i=e[s],r=typeof i;"object"===r?await this.engine.import(i,a):"function"===r?await this.engine.defRule(a,i):await this.engine.assert(a,i);continue}let a=e[s];switch(s){case"#assert":await this.engine.assert(a.path,a.value);break;case"#retract":await this.engine.retract(a.path);break;case"#defRule":await this.engine.defRule(a.path,a.value);break;case"#undefRule":await this.engine.undefRule(a.path);break;case"#import":await this.engine.import(a.value,a.path);break;default:throw new Error(`Invalid action: '${s}'.`)}}}}}},568:(t,e,s)=>{const a=s(74),i=s(743),r=s(980);function n(t){this._trace&&this._trace({action:"undefRule",rule:t}),this._rules.delete(t);for(const[e,s]of this._relations)s.delete(t)}async function h(){this._trace&&this._trace({action:"infer",maxGen:this._maxGen}),this._busy=!0;let t=0;this._facts.set("/$/maxGen",this._maxGen);try{for(;t<this._maxGen&&this._agenda.size>0;){t++,this._facts.set("/$/gen",t),this._trace&&this._trace({action:"executeAgenda",gen:t,ruleCount:this._agenda.size});let e=this._agenda;this._agenda=new Map;for(const[t,s]of e)await s.execute()}}finally{this._busy=!1}if(t==this._maxGen)throw new Error(`Inference not completed because maximum depth reached (${this._maxGen}). Please review for infinite loop or set the maxDepth property to a larger value.`)}async function c(t,e){let s=e;if(e.endsWith("/")&&(s=e.substring(0,e.length-1)),t instanceof Date||t instanceof Array)return await this.assert(s,t);const a=typeof t;if("function"===a)return await this.defRule(s,t);if("object"!==a)return await this.assert(s,t);for(let e in t)await c.call(this,t[e],`${s}/${e}`)}function o(t){this._relations.has(t)&&this._relations.get(t).forEach((t=>{this._agenda.set(t,this._rules.get(t)),this._trace&&this._trace({action:"addToAgenda",rule:t})}))}function l(t,e,s){let a=e[0];1!==e.length?(void 0===t[a]&&(t[a]={}),l(t[a],e.slice(1),s)):t[a]=s}t.exports=class{constructor(t,e){this._maxGen=t||50,this._trace=e,this._busy=!1,this._facts=new Map,this._rules=new Map,this._relations=new Map,this._agenda=new Map,this._changes=new Set}async peek(t){let e=t.startsWith("/")?t:`/${t}`,s=a.compilePath(e);return this._facts.get(s)}async assert(t,e){let s=t.startsWith("/")?t:`/${t}`,i=a.compilePath(s);var r=this._facts.get(i);if(!(e instanceof Array)&&a.equals(r,e))return;let n="assert";if(void 0!==e)this._facts.set(i,e);else{if(!this._facts.has(i))return void(this._trace&&this._trace({action:"retract",warning:`Cannot retract undefined fact '${i}'.`}));n="retract",this._facts.delete(i),this._relations.delete(i)}this._trace&&this._trace({action:n,fact:i,oldValue:r,newValue:e}),i.startsWith("/$")||(this._changes.add(i),o.call(this,i),this._busy||await h.call(this))}async assertAll(t){if(!(t instanceof Array))throw new Error("The 'facts' parameter must be an Array.");if(0!==t.length){this._trace&&this._trace({action:"assertAll",factCount:t.length}),this._busy=!0;try{for(const e of t){if(!(e instanceof r))throw new Error("The asserted array must contains objects of type Fact only.");await this.assert(e.path,e.value)}}finally{this.busy=!1}await h.call(this)}}async retract(t){if(!t.endsWith("/*"))return void await this.assert(t,void 0);let e=t.startsWith("/")?t:`/${t}`,s=a.compilePath(e),i=s.substr(0,s.length-1);for(const[t,e]of this._facts)t.startsWith(i)&&await this.assert(t,void 0)}async defRule(t,e){if("async"!==(e&&e.toString().substring(0,5)))throw new Error("The rule parameter must be an async function.");let s=t.startsWith("/")?t:`/${t}`,r=a.compilePath(s),n=a.getContext(r);if(this._rules.has(r))throw new Error(`Can not define the rule '${r}' because it already exist. Call 'undefRule' or change the rule path.`);let c=new i(this,e,r),o=a.parseParameters(e);for(const t of o){let e=t.startsWith("/")?t:n+t,s=a.compilePath(e);this._relations.has(s)||this._relations.set(s,new Set),this._relations.get(s).add(r),c.facts.push(s)}this._rules.set(r,c),this._trace&&this._trace({action:"defRule",rule:r,inputFacts:c.facts.slice()}),this._agenda.set(r,c),this._trace&&this._trace({action:"addToAgenda",rule:t}),this._busy||await h.call(this)}async undefRule(t){let e=t.startsWith("/")?t:`/${t}`,s=a.compilePath(e);if(!s.endsWith("/*"))return void n.call(this,s);let i=s.substr(0,s.length-1);for(const[t,e]of this._rules)t.startsWith(i)&&n.call(this,t)}async import(t,e){this._trace&&this._trace({action:"import",object:t});let s=this._busy;this._busy=!0;try{await c.call(this,t,e||""),s||await h.call(this)}finally{s||(this._busy=!1)}}async export(t){let e=t||"/";e.startsWith("/")||(e=`/${e}`);let s={};for(const[t,a]of this._facts)t.startsWith(e)&&l(s,t.substring(e.length).replace(/\//g," ").trim().split(" "),a);return s}async exportChanges(){let t={};for(const e of this._changes)l(t,e.replace(/\//g," ").trim().split(" "),this._facts.get(e));return this._changes.clear(),t}async reset(){this._changes.clear()}static fact(t,e){return new r(t,e)}}},74:t=>{t.exports={equals:function(t,e){var s=t;t instanceof Date&&(s=t.getTime());var a=e;return e instanceof Date&&(a=e.getTime()),s===a},parseParameters:function*(t){let s=(t.toString().split(")")[0]+")").replace(/\s+/g," "),a=/\((.+?)\)|= ?(?:async)? ?(\w+) ?=>/g.exec(s);if(!a)return;let i=a[1],r=e.exec(i);do{yield r[1]||r[2],r=e.exec(i)}while(r)},getContext:function(t){return t.replace(s,"")},compilePath:function(t){let e=t,s=t.replace(a,"");for(;s!=e;)e=s,s=e.replace(a,"");if(e.startsWith("/.."))throw new Error(`Unable to compile the path '${t}' properly.`);return e.replace(i,"")}};const e=/(?:\/\*?@ *([\w/.]+?) *\*\/ *\w+,?)|[(,]? *(\w+) *[,)]?/g,s=/[^/]+?$/,a=/\/[^/.]+\/\.\./,i=/\.\//g}},e={},function s(a){if(e[a])return e[a].exports;var i=e[a]={exports:{}};return t[a](i,i.exports,s),i.exports}(568);var t,e}));
//# sourceMappingURL=infernal-engine.js.map